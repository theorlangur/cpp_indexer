diff --git a/.gitignore b/.gitignore
index b33fbbf93237..ddc34575f564 100644
--- a/.gitignore
+++ b/.gitignore
@@ -26,6 +26,8 @@
 
 # Nested build directory
 /build*
+/Debug*
+/Release*
 
 #==============================================================================#
 # Explicit files to ignore (only matches one).
diff --git a/clang-tools-extra/clangd/CMakeLists.txt b/clang-tools-extra/clangd/CMakeLists.txt
index 671e55e8622d..645cb59910a2 100644
--- a/clang-tools-extra/clangd/CMakeLists.txt
+++ b/clang-tools-extra/clangd/CMakeLists.txt
@@ -80,6 +80,8 @@ add_clang_library(clangDaemon
   JSONTransport.cpp
   PathMapping.cpp
   Protocol.cpp
+  PCHManager.cpp
+  PCHManagerQueue.cpp
   Quality.cpp
   ParsedAST.cpp
   Preamble.cpp
diff --git a/clang-tools-extra/clangd/ClangdLSPServer.cpp b/clang-tools-extra/clangd/ClangdLSPServer.cpp
index f70fd0018cfd..b158f0923da3 100644
--- a/clang-tools-extra/clangd/ClangdLSPServer.cpp
+++ b/clang-tools-extra/clangd/ClangdLSPServer.cpp
@@ -681,7 +681,7 @@ void ClangdLSPServer::onDocumentDidChange(
     }
   }
   Server->addDocument(File, NewCode, encodeVersion(Params.textDocument.version),
-                      WantDiags, Params.forceRebuild);
+                      WantDiags, Params.forceRebuild, true);
 }
 
 void ClangdLSPServer::onDocumentDidSave(
@@ -1605,9 +1605,10 @@ void ClangdLSPServer::onBackgroundIndexProgress(
       WorkDoneProgressReport Report;
       Report.percentage = 100 * (Stats.Completed - Stats.LastIdle) /
                           (Stats.Enqueued - Stats.LastIdle);
+      const char *Prefix = Stats.StatType == BackgroundQueue::Stats::Type::PCH ? "PCH " : "";
       Report.message =
-          llvm::formatv("{0}/{1}", Stats.Completed - Stats.LastIdle,
-                        Stats.Enqueued - Stats.LastIdle);
+          llvm::formatv("{2}{0}/{1}", Stats.Completed - Stats.LastIdle,
+                        Stats.Enqueued - Stats.LastIdle, Prefix);
       ReportWorkDoneProgress({ProgressToken, std::move(Report)});
     } else {
       assert(Stats.Completed == Stats.Enqueued);
diff --git a/clang-tools-extra/clangd/ClangdServer.cpp b/clang-tools-extra/clangd/ClangdServer.cpp
index 0f525f3b9a0a..f7bca0b2b3c3 100644
--- a/clang-tools-extra/clangd/ClangdServer.cpp
+++ b/clang-tools-extra/clangd/ClangdServer.cpp
@@ -16,6 +16,7 @@
 #include "HeaderSourceSwitch.h"
 #include "Headers.h"
 #include "InlayHints.h"
+#include "PCHManager.h"
 #include "ParsedAST.h"
 #include "Preamble.h"
 #include "Protocol.h"
@@ -24,6 +25,7 @@
 #include "SourceCode.h"
 #include "TUScheduler.h"
 #include "XRefs.h"
+#include "index/Background.h"
 #include "index/CanonicalIncludes.h"
 #include "index/FileIndex.h"
 #include "index/Merge.h"
@@ -160,12 +162,47 @@ ClangdServer::ClangdServer(const GlobalCompilationDatabase &CDB,
       Transient(Opts.ImplicitCancellation ? TUScheduler::InvalidateOnUpdate
                                           : TUScheduler::NoInvalidation),
       DirtyFS(std::make_unique<DraftStoreFS>(TFS, DraftMgr)) {
+
+  std::unique_ptr<ParsingCallbacks> ParseCB = std::make_unique<UpdateIndexCallbacks>(DynamicIdx.get(), Callbacks);
+  PCHManager::Options PCHOpts;
+  PCHOpts.OnProgress = [Callbacks](PCHManager::Stats S) {
+    if (Callbacks)
+    {
+      BackgroundQueue::Stats T;
+      T.StatType = BackgroundQueue::Stats::Type::PCH;
+      T.Completed = S.Completed;
+      T.Enqueued = S.Total;
+      Callbacks->onBackgroundIndexProgress(T);
+    }
+  };
+  PCHOpts.WaitForInit = Opts.PCHAlwaysWait;
+  PrecompiledHeaderMgr = std::make_unique<PCHManager>(CDB, TFS, *ParseCB, PCHOpts);
+  PCHWasBuild = PrecompiledHeaderMgr->watch([this](PCHManager::PCHEvent const &E) {
+	vlog("PCH was built: {0}; Success: {1}", E.PCHPath, E.Success);
+    if (!E.Success)
+      return;
+    reparseOpenFilesIfNeeded([&](StringRef File) -> bool {
+	  vlog("After PCH update: checking {0}", File);
+      auto Cmd = this->CDB.getCompileCommand(File);
+      if (Cmd) {
+	    //log("After PCH update: found command for {0}", File);
+        bool r = PrecompiledHeaderMgr->hasPCHInDependencies(*Cmd, E.PCHPath);
+        if (r) {
+          log("PCH {0} updated. Updating {1} that depends on it", E.PCHPath,
+              File);
+        }
+        return r;
+      }
+      return false;
+    });
+  });
+
   // Pass a callback into `WorkScheduler` to extract symbols from a newly
   // parsed file and rebuild the file index synchronously each time an AST
   // is parsed.
   WorkScheduler.emplace(
       CDB, TUScheduler::Options(Opts),
-      std::make_unique<UpdateIndexCallbacks>(DynamicIdx.get(), Callbacks));
+      std::move(ParseCB), PrecompiledHeaderMgr.get());
   // Adds an index to the stack, at higher priority than existing indexes.
   auto AddIndex = [&](SymbolIndex *Idx) {
     if (this->Index != nullptr) {
@@ -175,6 +212,7 @@ ClangdServer::ClangdServer(const GlobalCompilationDatabase &CDB,
       this->Index = Idx;
     }
   };
+
   if (Opts.StaticIndex)
     AddIndex(Opts.StaticIndex);
   if (Opts.BackgroundIndex) {
@@ -189,7 +227,7 @@ ClangdServer::ClangdServer(const GlobalCompilationDatabase &CDB,
         TFS, CDB,
         BackgroundIndexStorage::createDiskBackedStorageFactory(
             [&CDB](llvm::StringRef File) { return CDB.getProjectInfo(File); }),
-        std::move(BGOpts));
+        std::move(BGOpts), PrecompiledHeaderMgr.get());
     AddIndex(BackgroundIdx.get());
   }
   if (DynamicIdx)
@@ -222,10 +260,25 @@ ClangdServer::~ClangdServer() {
 
 void ClangdServer::addDocument(PathRef File, llvm::StringRef Contents,
                                llvm::StringRef Version,
-                               WantDiagnostics WantDiags, bool ForceRebuild) {
+                               WantDiagnostics WantDiags, bool ForceRebuild, bool AfterChange) {
+  bool Existed = DraftMgr.getDraft(File).hasValue();
   std::string ActualVersion = DraftMgr.addDraft(File, Version, Contents);
   ParseOptions Opts;
 
+  auto draftVFS = DraftMgr.asVFS();
+
+  if (Existed && AfterChange)
+  {
+    //slow. needs to be done in bulk
+    PrecompiledHeaderMgr->checkChangedFile(File, draftVFS);
+  }
+
+  {
+    auto CC = CDB.getCompileCommand(File);
+    if (CC)
+		PrecompiledHeaderMgr->tryAddDynamicPCH(*CC, draftVFS);
+  }
+
   // Compile command is set asynchronously during update, as it can be slow.
   ParseInputs Inputs;
   Inputs.TFS = &TFS;
@@ -236,6 +289,7 @@ void ClangdServer::addDocument(PathRef File, llvm::StringRef Contents,
   Inputs.Index = Index;
   Inputs.ClangTidyProvider = ClangTidyProvider;
   Inputs.FeatureModules = FeatureModules;
+  Inputs.DraftFS = draftVFS;
   bool NewFile = WorkScheduler->update(File, Inputs, WantDiags);
   // If we loaded Foo.h, we want to make sure Foo.cpp is indexed.
   if (NewFile && BackgroundIdx)
@@ -339,6 +393,11 @@ ClangdServer::createConfiguredContextProvider(const config::Provider *Provider,
 void ClangdServer::removeDocument(PathRef File) {
   DraftMgr.removeDraft(File);
   WorkScheduler->remove(File);
+  {
+    auto CC = CDB.getCompileCommand(File);
+    if (CC)
+		PrecompiledHeaderMgr->tryRemoveDynamicPCH(*CC);
+  }
 }
 
 void ClangdServer::codeComplete(PathRef File, Position Pos,
@@ -357,7 +416,7 @@ void ClangdServer::codeComplete(PathRef File, Position Pos,
       return CB(llvm::make_error<CancelledError>(Reason));
 
     llvm::Optional<SpeculativeFuzzyFind> SpecFuzzyFind;
-    if (!IP->Preamble) {
+    if (!IP->Preamble && !IP->PCH) {
       // No speculation in Fallback mode, as it's supposed to be much faster
       // without compiling.
       vlog("Build for file {0} is not ready. Enter fallback mode.", File);
@@ -376,7 +435,7 @@ void ClangdServer::codeComplete(PathRef File, Position Pos,
     // FIXME(ibiryukov): even if Preamble is non-null, we may want to check
     // both the old and the new version in case only one of them matches.
     CodeCompleteResult Result = clangd::codeComplete(
-        File, Pos, IP->Preamble, ParseInput, CodeCompleteOpts,
+        File, Pos, IP->Preamble, ParseInput, std::move(IP->PCH), CodeCompleteOpts,
         SpecFuzzyFind ? SpecFuzzyFind.getPointer() : nullptr);
     {
       clang::clangd::trace::Span Tracer("Completion results callback");
@@ -411,12 +470,12 @@ void ClangdServer::signatureHelp(PathRef File, Position Pos,
       return CB(IP.takeError());
 
     const auto *PreambleData = IP->Preamble;
-    if (!PreambleData)
+    if (!PreambleData && !IP->PCH)
       return CB(error("Failed to parse includes"));
 
     ParseInputs ParseInput{IP->Command, &TFS, IP->Contents.str()};
     ParseInput.Index = Index;
-    CB(clangd::signatureHelp(File, Pos, *PreambleData, ParseInput));
+    CB(clangd::signatureHelp(File, Pos, PreambleData, ParseInput, std::move(IP->PCH)));
   };
 
   // Unlike code completion, we wait for a preamble here.
diff --git a/clang-tools-extra/clangd/ClangdServer.h b/clang-tools-extra/clangd/ClangdServer.h
index 7d98977a7056..dffd326561b2 100644
--- a/clang-tools-extra/clangd/ClangdServer.h
+++ b/clang-tools-extra/clangd/ClangdServer.h
@@ -17,6 +17,7 @@
 #include "FeatureModule.h"
 #include "GlobalCompilationDatabase.h"
 #include "Hover.h"
+#include "PCHManager.h"
 #include "Protocol.h"
 #include "SemanticHighlighting.h"
 #include "TUScheduler.h"
@@ -166,6 +167,9 @@ public:
 
     FeatureModuleSet *FeatureModules = nullptr;
 
+    //defines wether operations on TUs should wait for PCHs manager to be initialized on the start
+    bool PCHAlwaysWait = true;
+
     explicit operator TUScheduler::Options() const;
   };
   // Sensible default options for use in tests.
@@ -201,7 +205,7 @@ public:
   void addDocument(PathRef File, StringRef Contents,
                    llvm::StringRef Version = "null",
                    WantDiagnostics WD = WantDiagnostics::Auto,
-                   bool ForceRebuild = false);
+                   bool ForceRebuild = false, bool AfterChange = false);
 
   /// Remove \p File from list of tracked files, schedule a request to free
   /// resources associated with it. Pending diagnostics for closed files may not
@@ -403,6 +407,9 @@ private:
   std::unique_ptr<BackgroundIndex> BackgroundIdx;
   // Storage for merged views of the various indexes.
   std::vector<std::unique_ptr<SymbolIndex>> MergedIdx;
+  // If present, an index of symbols in open files. Read via *Index.
+  std::unique_ptr<PCHManager> PrecompiledHeaderMgr;
+  PCHManager::PCHBuiltEvent::Subscription PCHWasBuild;
 
   // When set, provides clang-tidy options for a specific file.
   TidyProviderRef ClangTidyProvider;
diff --git a/clang-tools-extra/clangd/CodeComplete.cpp b/clang-tools-extra/clangd/CodeComplete.cpp
index 19f33a40f889..7963aceecdcf 100644
--- a/clang-tools-extra/clangd/CodeComplete.cpp
+++ b/clang-tools-extra/clangd/CodeComplete.cpp
@@ -1092,7 +1092,8 @@ private:
 struct SemaCompleteInput {
   PathRef FileName;
   size_t Offset;
-  const PreambleData &Preamble;
+  PCHManager::PCHAccess PCH;
+  const PreambleData *Preamble;
   const llvm::Optional<PreamblePatch> Patch;
   const ParseInputs &ParseInput;
 };
@@ -1142,12 +1143,14 @@ bool semaCodeComplete(std::unique_ptr<CodeCompleteConsumer> Consumer,
   // This is on-by-default in windows to allow parsing SDK headers; we're only
   // disabling it for the main-file (not preamble).
   CI->getLangOpts()->DelayedTemplateParsing = false;
+  CI->getPreprocessorOpts().addMacroDef("_CLANGD_CODE_COMPLETE_");
   // Setup code completion.
   FrontendOpts.CodeCompleteOpts = Options;
   FrontendOpts.CodeCompletionAt.FileName = std::string(Input.FileName);
   std::tie(FrontendOpts.CodeCompletionAt.Line,
            FrontendOpts.CodeCompletionAt.Column) =
       offsetToClangLineColumn(Input.ParseInput.Contents, Input.Offset);
+  log("Sema complete at {0}:{1}", FrontendOpts.CodeCompletionAt.Line, FrontendOpts.CodeCompletionAt.Column);
 
   std::unique_ptr<llvm::MemoryBuffer> ContentsBuffer =
       llvm::MemoryBuffer::getMemBuffer(Input.ParseInput.Contents,
@@ -1160,23 +1163,54 @@ bool semaCodeComplete(std::unique_ptr<CodeCompleteConsumer> Consumer,
   // However, if we're completing *inside* the preamble section of the draft,
   // overriding the preamble will break sema completion. Fortunately we can just
   // skip all includes in this case; these completions are really simple.
-  PreambleBounds PreambleRegion =
-      ComputePreambleBounds(*CI->getLangOpts(), *ContentsBuffer, 0);
-  bool CompletingInPreamble = Input.Offset < PreambleRegion.Size ||
+  PreambleBounds PreambleRegion = Input.Preamble ?
+      ComputePreambleBounds(*CI->getLangOpts(), *ContentsBuffer, 0) : PreambleBounds(0, false);
+  bool CompletingInPreamble = Input.Preamble && (Input.Offset < PreambleRegion.Size ||
                               (!PreambleRegion.PreambleEndsAtStartOfLine &&
-                               Input.Offset == PreambleRegion.Size);
+                               Input.Offset == PreambleRegion.Size));
+  log("semaCodeComplete: preamble. completing in: {0}; bounds: sz: {1}; ends at start of line: {2}", CompletingInPreamble, PreambleRegion.Size, PreambleRegion.PreambleEndsAtStartOfLine);
+  if (Input.Preamble)
+  {
+    log("semaCodeComplete: preamble size: {0}", Input.Preamble->Preamble.getSize());
+  }
   if (Input.Patch)
+  {
+    log("semaCodeComplete: applying patch");
     Input.Patch->apply(*CI);
+  }
+
   // NOTE: we must call BeginSourceFile after prepareCompilerInstance. Otherwise
   // the remapped buffers do not get freed.
   llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS =
       Input.ParseInput.TFS->view(Input.ParseInput.CompileCommand.Directory);
-  if (Input.Preamble.StatCache)
-    VFS = Input.Preamble.StatCache->getConsumingFS(std::move(VFS));
+  if (Input.Preamble && Input.Preamble->StatCache)
+    VFS = Input.Preamble->StatCache->getConsumingFS(std::move(VFS));
+  if (Input.PCH)
+  {
+    log("Applying PCH for code complete action for {0}. PCH: {1}", Input.FileName, Input.PCH.filename());
+    Input.PCH.addPCH(CI.get(), VFS);
+    /*
+    auto &PreprocessorOpts = CI->getPreprocessorOpts();
+    PreprocessorOpts.PrecompiledPreambleBytes.first = 0;
+    PreprocessorOpts.PrecompiledPreambleBytes.second = false;
+    */
+    /*
+    PreambleBounds PreambleRegion = ComputePreambleBounds(*CI->getLangOpts(), *ContentsBuffer, 0);
+    auto &PreprocessorOpts = CI->getPreprocessorOpts();
+    PreprocessorOpts.PrecompiledPreambleBytes.first = PreambleRegion.Size;
+    PreprocessorOpts.PrecompiledPreambleBytes.second =
+        PreambleRegion.PreambleEndsAtStartOfLine;
+    PreprocessorOpts.DisablePCHOrModuleValidation =
+        DisableValidationForModuleKind::PCH;
+    log("semaCodeComplete: pch-preamble. bounds: sz: {0}; ends at start of line: {1}", PreambleRegion.Size, PreambleRegion.PreambleEndsAtStartOfLine);
+    */
+  }
+
+  const clang::PrecompiledPreamble *Prmbl = !CompletingInPreamble && Input.Preamble ? &Input.Preamble->Preamble : nullptr;
   auto Clang = prepareCompilerInstance(
-      std::move(CI), !CompletingInPreamble ? &Input.Preamble.Preamble : nullptr,
+      std::move(CI), Prmbl,
       std::move(ContentsBuffer), std::move(VFS), IgnoreDiags);
-  Clang->getPreprocessorOpts().SingleFileParseMode = CompletingInPreamble;
+  Clang->getPreprocessorOpts().SingleFileParseMode = CompletingInPreamble;// || Input.PCH;
   Clang->setCodeCompletionConsumer(Consumer.release());
 
   SyntaxOnlyAction Action;
@@ -1191,7 +1225,8 @@ bool semaCodeComplete(std::unique_ptr<CodeCompleteConsumer> Consumer,
   //  - but Sema code complete won't see them: as part of the preamble, they're
   //    deserialized only when mentioned.
   // Force them to be deserialized so SemaCodeComplete sees them.
-  loadMainFilePreambleMacros(Clang->getPreprocessor(), Input.Preamble);
+  if (Input.Preamble)
+    loadMainFilePreambleMacros(Clang->getPreprocessor(), *Input.Preamble);
   if (Includes)
     Clang->getPreprocessor().addPPCallbacks(
         collectIncludeStructureCallback(Clang->getSourceManager(), Includes));
@@ -1778,7 +1813,6 @@ private:
     dlog("CodeComplete: {0} ({1}) = {2}\n{3}{4}\n", First.Name,
          llvm::to_string(Origin), Scores.Total, llvm::to_string(Quality),
          llvm::to_string(Relevance));
-
     NSema += bool(Origin & SymbolOrigin::AST);
     NIndex += FromIndex;
     NSemaAndIndex += bool(Origin & SymbolOrigin::AST) && FromIndex;
@@ -1851,6 +1885,7 @@ CompletionPrefix guessCompletionPrefix(llvm::StringRef Content,
 CodeCompleteResult codeComplete(PathRef FileName, Position Pos,
                                 const PreambleData *Preamble,
                                 const ParseInputs &ParseInput,
+                                PCHManager::PCHAccess PCH,
                                 CodeCompleteOptions Opts,
                                 SpeculativeFuzzyFind *SpecFuzzyFind) {
   auto Offset = positionToOffset(ParseInput.Contents, Pos);
@@ -1861,18 +1896,19 @@ CodeCompleteResult codeComplete(PathRef FileName, Position Pos,
   auto Flow = CodeCompleteFlow(
       FileName, Preamble ? Preamble->Includes : IncludeStructure(),
       SpecFuzzyFind, Opts);
-  return (!Preamble || Opts.RunParser == CodeCompleteOptions::NeverParse)
+  return ((!Preamble && !PCH) || Opts.RunParser == CodeCompleteOptions::NeverParse)
              ? std::move(Flow).runWithoutSema(ParseInput.Contents, *Offset,
                                               *ParseInput.TFS)
-             : std::move(Flow).run({FileName, *Offset, *Preamble,
+             : std::move(Flow).run({FileName, *Offset, std::move(PCH), Preamble,
                                     // We want to serve code completions with
                                     // low latency, so don't bother patching.
                                     /*PreamblePatch=*/llvm::None, ParseInput});
 }
 
 SignatureHelp signatureHelp(PathRef FileName, Position Pos,
-                            const PreambleData &Preamble,
-                            const ParseInputs &ParseInput) {
+                            const PreambleData *Preamble,
+                            const ParseInputs &ParseInput,
+                            PCHManager::PCHAccess PCH) {
   auto Offset = positionToOffset(ParseInput.Contents, Pos);
   if (!Offset) {
     elog("Signature help position was invalid {0}", Offset.takeError());
@@ -1884,12 +1920,13 @@ SignatureHelp signatureHelp(PathRef FileName, Position Pos,
   Options.IncludeMacros = false;
   Options.IncludeCodePatterns = false;
   Options.IncludeBriefComments = false;
+  llvm::Optional<PreamblePatch> Patch = !Preamble ? llvm::None : llvm::Optional<PreamblePatch>(PreamblePatch::create(FileName, ParseInput, *Preamble));
   semaCodeComplete(
       std::make_unique<SignatureHelpCollector>(Options, ParseInput.Index,
                                                Result),
       Options,
-      {FileName, *Offset, Preamble,
-       PreamblePatch::create(FileName, ParseInput, Preamble), ParseInput});
+      {FileName, *Offset, std::move(PCH), Preamble,
+       std::move(Patch), ParseInput});
   return Result;
 }
 
diff --git a/clang-tools-extra/clangd/CodeComplete.h b/clang-tools-extra/clangd/CodeComplete.h
index 40a528caa939..733a33edd876 100644
--- a/clang-tools-extra/clangd/CodeComplete.h
+++ b/clang-tools-extra/clangd/CodeComplete.h
@@ -18,6 +18,7 @@
 #include "ASTSignals.h"
 #include "Compiler.h"
 #include "Headers.h"
+#include "PCHManager.h"
 #include "Protocol.h"
 #include "Quality.h"
 #include "index/Index.h"
@@ -278,13 +279,15 @@ struct SpeculativeFuzzyFind {
 CodeCompleteResult codeComplete(PathRef FileName, Position Pos,
                                 const PreambleData *Preamble,
                                 const ParseInputs &ParseInput,
+                                PCHManager::PCHAccess PCH,
                                 CodeCompleteOptions Opts,
                                 SpeculativeFuzzyFind *SpecFuzzyFind = nullptr);
 
 /// Get signature help at a specified \p Pos in \p FileName.
 SignatureHelp signatureHelp(PathRef FileName, Position Pos,
-                            const PreambleData &Preamble,
-                            const ParseInputs &ParseInput);
+                            const PreambleData *Preamble,
+                            const ParseInputs &ParseInput,
+                            PCHManager::PCHAccess PCH);
 
 // For index-based completion, we only consider:
 //   * symbols in namespaces or translation unit scopes (e.g. no class
diff --git a/clang-tools-extra/clangd/CodeCompletionStrings.cpp b/clang-tools-extra/clangd/CodeCompletionStrings.cpp
index 8205c88a5b66..7e226df726e2 100644
--- a/clang-tools-extra/clangd/CodeCompletionStrings.cpp
+++ b/clang-tools-extra/clangd/CodeCompletionStrings.cpp
@@ -84,7 +84,9 @@ std::string getDeclComment(const ASTContext &Ctx, const NamedDecl &Decl) {
     return "";
   // Sanity check that the comment does not come from the PCH. We choose to not
   // write them into PCH, because they are racy and slow to load.
-  assert(!Ctx.getSourceManager().isLoadedSourceLocation(RC->getBeginLoc()));
+  //assert(!Ctx.getSourceManager().isLoadedSourceLocation(RC->getBeginLoc()));
+  if (Ctx.getSourceManager().isLoadedSourceLocation(RC->getBeginLoc()))
+    return "";
   std::string Doc =
       RC->getFormattedText(Ctx.getSourceManager(), Ctx.getDiagnostics());
   if (!looksLikeDocComment(Doc))
diff --git a/clang-tools-extra/clangd/Compiler.h b/clang-tools-extra/clangd/Compiler.h
index 035106968315..fe117fdb4e22 100644
--- a/clang-tools-extra/clangd/Compiler.h
+++ b/clang-tools-extra/clangd/Compiler.h
@@ -59,6 +59,8 @@ struct ParseInputs {
   TidyProviderRef ClangTidyProvider = {};
   // Used to acquire ASTListeners when parsing files.
   FeatureModuleSet *FeatureModules = nullptr;
+
+  IntrusiveRefCntPtr<llvm::vfs::FileSystem> DraftFS;
 };
 
 /// Builds compiler invocation that could be used to build AST or preamble.
diff --git a/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp b/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
index d830190bfdfd..50f13575c611 100644
--- a/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
+++ b/clang-tools-extra/clangd/GlobalCompilationDatabase.cpp
@@ -547,6 +547,15 @@ public:
     Thread.join();
   }
 };
+  
+template<class T>
+struct GetPathHelper;
+
+template<>
+struct GetPathHelper<std::string> { static llvm::StringRef val(std::string &I) { return I;} };
+
+template<>
+struct GetPathHelper<tooling::CompileCommand> { static llvm::StringRef val(tooling::CompileCommand &I) { return I.Filename;} };
 
 // The DirBasedCDB associates each file with a specific CDB.
 // When a CDB is discovered, it may claim to describe files that we associate
@@ -661,9 +670,11 @@ public:
          DirectoryBasedGlobalCompilationDatabase &Parent)
       : ThisDir(ThisDir), Parent(Parent) {}
 
-  std::vector<std::string> filter(std::vector<std::string> AllFiles,
+  template<class T>
+  std::vector<T> filter(std::vector<T> AllFiles,
                                   std::atomic<bool> &ShouldStop) {
-    std::vector<std::string> Filtered;
+    std::vector<T> Filtered;
+    using helper = GetPathHelper<T>;
     // Allow for clean early-exit of the slow parts.
     auto ExitEarly = [&] {
       if (ShouldStop.load(std::memory_order_acquire)) {
@@ -683,7 +694,7 @@ public:
       }
       if (ExitEarly()) // loading config may be slow
         return Filtered;
-      WithContext WithProvidedContent(Parent.Opts.ContextProvider(AllFiles[I]));
+      WithContext WithProvidedContent(Parent.Opts.ContextProvider(helper::val(AllFiles[I])));
       const Config::CDBSearchSpec &Spec =
           Config::current().CompileFlags.CDBSearch;
       switch (Spec.Policy) {
@@ -691,7 +702,7 @@ public:
         break;
       case Config::CDBSearchSpec::Ancestors:
         SearchPaths[I].setInt(/*Recursive=*/1);
-        SearchPaths[I].setPointer(addParents(AllFiles[I]));
+        SearchPaths[I].setPointer(addParents(helper::val(AllFiles[I])));
         break;
       case Config::CDBSearchSpec::FixedDir:
         SearchPaths[I].setPointer(&Dirs[Spec.FixedCDBPath.getValue()]);
@@ -718,6 +729,12 @@ void DirectoryBasedGlobalCompilationDatabase::BroadcastThread::process(
       Filter(T.PI.SourceRoot, Parent).filter(T.CDB->getAllFiles(), ShouldStop);
   if (!GovernedFiles.empty())
     Parent.OnCommandChanged.broadcast(std::move(GovernedFiles));
+
+  vlog("Broadcasting compilation database (PCH) from {0}", T.PI.SourceRoot);
+  std::vector<tooling::CompileCommand> PCHGovernedFiles =
+      Filter(T.PI.SourceRoot, Parent).filter(T.CDB->getAllPCHCompileCommands(), ShouldStop);
+
+  Parent.OnPCHAnnounce.broadcast(std::move(PCHGovernedFiles));
 }
 
 void DirectoryBasedGlobalCompilationDatabase::broadcastCDB(
@@ -797,9 +814,14 @@ void OverlayCDB::setCompileCommand(
 DelegatingCDB::DelegatingCDB(const GlobalCompilationDatabase *Base)
     : Base(Base) {
   if (Base)
+  {
     BaseChanged = Base->watch([this](const std::vector<std::string> Changes) {
       OnCommandChanged.broadcast(Changes);
     });
+    BasePCHAnnounce = Base->watch([this](const std::vector<tooling::CompileCommand> PCHs) {
+      OnPCHAnnounce.broadcast(PCHs);
+    });
+  }
 }
 
 DelegatingCDB::DelegatingCDB(std::unique_ptr<GlobalCompilationDatabase> Base)
diff --git a/clang-tools-extra/clangd/GlobalCompilationDatabase.h b/clang-tools-extra/clangd/GlobalCompilationDatabase.h
index b6e2fa3bccdf..54aa309a83a6 100644
--- a/clang-tools-extra/clangd/GlobalCompilationDatabase.h
+++ b/clang-tools-extra/clangd/GlobalCompilationDatabase.h
@@ -62,8 +62,16 @@ public:
     return OnCommandChanged.observe(std::move(L));
   }
 
+  using PCHAnnounce = Event<std::vector<tooling::CompileCommand>>;
+
+  PCHAnnounce::Subscription watch(PCHAnnounce::Listener L) const {
+    return OnPCHAnnounce.observe(std::move(L));
+  }
+
+
 protected:
   mutable CommandChanged OnCommandChanged;
+  mutable PCHAnnounce OnPCHAnnounce;
 };
 
 // Helper class for implementing GlobalCompilationDatabases that wrap others.
@@ -85,6 +93,7 @@ private:
   const GlobalCompilationDatabase *Base;
   std::unique_ptr<GlobalCompilationDatabase> BaseOwner;
   CommandChanged::Subscription BaseChanged;
+  PCHAnnounce::Subscription BasePCHAnnounce;
 };
 
 /// Gets compile args from tooling::CompilationDatabases built for parent
diff --git a/clang-tools-extra/clangd/PCHManager.cpp b/clang-tools-extra/clangd/PCHManager.cpp
new file mode 100644
index 000000000000..014249601c45
--- /dev/null
+++ b/clang-tools-extra/clangd/PCHManager.cpp
@@ -0,0 +1,969 @@
+#include "PCHManager.h"
+#include "Preamble.h"
+#include "TUScheduler.h"
+#include "support/Logger.h"
+#include "clang/Basic/DiagnosticIDs.h"
+#include "clang/Basic/OpenMPKinds.h"
+#include "clang/Frontend/FrontendActions.h"
+#include "clang/Frontend/PrecompiledPreamble.h"
+#include "clang/Lex/PreprocessorOptions.h"
+#include "clang/Serialization/ASTWriter.h"
+#include "clang/Serialization/PCHContainerOperations.h"
+#include "clang/Tooling/CompilationDatabase.h"
+#include "llvm/ADT/None.h"
+#include "llvm/ADT/ScopeExit.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/StringSet.h"
+#include "llvm/Support/CrashRecoveryContext.h"
+#include <algorithm>
+#include <iterator>
+#include <memory>
+#include <mutex>
+#include <shared_mutex>
+#include <string>
+#include <utility>
+
+namespace clang {
+namespace clangd {
+namespace {
+
+class PrecompilePCHAction : public ASTFrontendAction {
+public:
+  PrecompilePCHAction(std::string *InMemStorage, PreambleCallbacks &Callbacks)
+      : InMemStorage(InMemStorage), Callbacks(Callbacks) {}
+
+  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
+                                                 StringRef InFile) override;
+
+  bool hasEmittedPreamblePCH() const { return HasEmittedPreamblePCH; }
+
+  void setEmittedPreamblePCH(ASTWriter &Writer) {
+    this->HasEmittedPreamblePCH = true;
+    Callbacks.AfterPCHEmitted(Writer);
+  }
+
+  bool BeginSourceFileAction(CompilerInstance &CI) override {
+    assert(CI.getLangOpts().CompilingPCH);
+    return ASTFrontendAction::BeginSourceFileAction(CI);
+  }
+
+  bool shouldEraseOutputFiles() override { return !hasEmittedPreamblePCH(); }
+  bool hasCodeCompletionSupport() const override { return false; }
+  bool hasASTFileSupport() const override { return false; }
+  TranslationUnitKind getTranslationUnitKind() override { return TU_Prefix; }
+
+private:
+  friend class PrecompilePCHConsumer;
+
+  bool HasEmittedPreamblePCH = false;
+  std::string *InMemStorage;
+  PreambleCallbacks &Callbacks;
+};
+
+class PrecompilePCHConsumer : public PCHGenerator {
+public:
+  PrecompilePCHConsumer(PrecompilePCHAction &Action, const Preprocessor &PP,
+                        InMemoryModuleCache &ModuleCache, StringRef Isysroot,
+                        std::unique_ptr<raw_ostream> Out)
+      : PCHGenerator(PP, ModuleCache, "", Isysroot,
+                     std::make_shared<PCHBuffer>(),
+                     ArrayRef<std::shared_ptr<ModuleFileExtension>>(),
+                     /*AllowASTWithErrors=*/true),
+        Action(Action), Out(std::move(Out)) {}
+
+  bool HandleTopLevelDecl(DeclGroupRef DG) override {
+    Action.Callbacks.HandleTopLevelDecl(DG);
+    return true;
+  }
+
+  void HandleTranslationUnit(ASTContext &Ctx) override {
+    PCHGenerator::HandleTranslationUnit(Ctx);
+    if (!hasEmittedPCH())
+      return;
+
+    // Write the generated bitstream to "Out".
+    *Out << getPCH();
+    // Make sure it hits disk now.
+    Out->flush();
+    // Free the buffer.
+    llvm::SmallVector<char, 0> Empty;
+    getPCH() = std::move(Empty);
+
+    Action.setEmittedPreamblePCH(getWriter());
+  }
+
+  bool shouldSkipFunctionBody(Decl *D) override {
+    return Action.Callbacks.shouldSkipFunctionBody(D);
+  }
+
+private:
+  PrecompilePCHAction &Action;
+  std::unique_ptr<raw_ostream> Out;
+};
+
+std::unique_ptr<ASTConsumer>
+PrecompilePCHAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {
+  std::string Sysroot;
+  if (!GeneratePCHAction::ComputeASTConsumerArguments(CI, Sysroot))
+    return nullptr;
+
+  std::unique_ptr<llvm::raw_ostream> OS;
+  if (InMemStorage) {
+    OS = std::make_unique<llvm::raw_string_ostream>(*InMemStorage);
+  } else {
+    std::string OutputFile;
+    OS = GeneratePCHAction::CreateOutputFile(CI, InFile, OutputFile);
+  }
+  if (!OS)
+    return nullptr;
+
+  if (!CI.getFrontendOpts().RelocatablePCH)
+    Sysroot.clear();
+
+  return std::make_unique<PrecompilePCHConsumer>(
+      *this, CI.getPreprocessor(), CI.getModuleCache(), Sysroot, std::move(OS));
+}
+
+class CppFilePreambleCallbacks : public PreambleCallbacks {
+public:
+  CppFilePreambleCallbacks(PathRef File, PreambleParsedCallback ParsedCallback)
+      : File(File), ParsedCallback(ParsedCallback) {}
+
+  IncludeStructure takeIncludes() { return std::move(Includes); }
+
+  CanonicalIncludes takeCanonicalIncludes() { return std::move(CanonIncludes); }
+
+  void AfterExecute(CompilerInstance &CI) override {
+    if (!ParsedCallback)
+      return;
+    trace::Span Tracer("Running PreambleCallback");
+    ParsedCallback(CI.getASTContext(), CI.getPreprocessorPtr(), CanonIncludes);
+  }
+
+  void BeforeExecute(CompilerInstance &CI) override {
+    CanonIncludes.addSystemHeadersMapping(CI.getLangOpts());
+    LangOpts = &CI.getLangOpts();
+    SourceMgr = &CI.getSourceManager();
+  }
+
+  std::unique_ptr<PPCallbacks> createPPCallbacks() override {
+    assert(SourceMgr && LangOpts &&
+           "SourceMgr and LangOpts must be set at this point");
+
+    return collectIncludeStructureCallback(*SourceMgr, &Includes);
+  }
+
+private:
+  PathRef File;
+  PreambleParsedCallback ParsedCallback;
+  IncludeStructure Includes;
+  CanonicalIncludes CanonIncludes;
+  const clang::LangOptions *LangOpts = nullptr;
+  const SourceManager *SourceMgr = nullptr;
+};
+} // namespace
+
+PCHManager::PCHManager(const GlobalCompilationDatabase &CDB,
+                       const ThreadsafeFS &TFS, ParsingCallbacks &Callbacks,
+                       const Options &Opts)
+    : CDB(CDB), TFS(TFS), Callbacks(Callbacks),
+      OnProgress(std::move(Opts.OnProgress)),
+      CommandsChanged(
+          CDB.watch([&](const std::vector<std::string> &ChangedFiles) {
+            enqueue(ChangedFiles, FSType());
+          })),
+      PCHAnnounce(CDB.watch(
+          [&](const std::vector<tooling::CompileCommand> &PCHAnnounced) {
+            enqueue(PCHAnnounced);
+          })),
+      WaitForInit(Opts.WaitForInit) {
+  ThreadPool.runAsync("pch-worker",
+                      [this, Ctx(Context::current().clone())]() mutable {
+                        WithContext BGContext(std::move(Ctx));
+                        Queue.work([&]{Queue.push(checkChangedPeriodically());});
+                      });
+}
+
+PCHManager::~PCHManager() { Queue.stop(); }
+
+PCHQueue::Task
+PCHManager::changedFilesTask(const std::vector<std::string> &ChangedFiles,
+                             FSType FS) {
+  PCHQueue::Task T([this, ChangedFiles, FS] {
+    unsigned Invalidated = invalidateAffectedPCH(ChangedFiles);
+    rebuildInvalidatedPCH(Invalidated, FS);
+    updateAllHeaders();
+  });
+
+  T.ThreadPri = llvm::ThreadPriority::Default;
+  return T;
+}
+
+PCHQueue::Task PCHManager::checkChangedPeriodically()
+{
+  PCHQueue::Task T([this] {
+    using namespace std::chrono_literals;
+    std::this_thread::sleep_for(500ms);
+    if (!Changed.empty())
+    {
+      std::unique_lock<std::mutex> Lock(ChangedMtx);
+      auto Dms = std::chrono::duration_cast<std::chrono::milliseconds>(clock_t::now() - ChangedLastTime).count();
+      if (Dms > 2000)
+      {
+        log("(PCH) sending changed file for processing ({0} items)", Changed.size());
+        enqueue(Changed, ChangedFS);
+        Changed.clear();
+        ChangedFS = nullptr;
+        return;
+      }
+    }
+
+    Queue.push(checkChangedPeriodically());
+  });
+  return T;
+}
+
+void PCHManager::checkChangedFile(PathRef File, FSType FS) {
+  if (!Initialized)
+  {
+      log("(PCH) check changed file: not initialized yet");
+      return;
+  }
+
+  {
+    shared_lck SharedAccessToAllHeaders(UsedHeadersLock);
+    if (!AllUsedHeaders.contains(File))
+    {
+      std::string LowerCase(File);
+      if (LowerCase[0] != std::tolower(LowerCase[0]))
+        LowerCase[0] = std::tolower(LowerCase[0]);
+      else
+        LowerCase[0] = std::toupper(LowerCase[0]);
+      if (!AllUsedHeaders.contains(LowerCase)) {
+        log("(PCH) file {0}/{1} doesn't affect any PCHs", File, LowerCase);
+        return;
+      }
+    }
+  }
+
+  {
+    std::unique_lock<std::mutex> Lock(ChangedMtx);
+    ChangedLastTime = clock_t::now();
+    Changed.emplace_back(File);
+    ChangedFS = FS;
+  }
+}
+
+void PCHManager::updateAllHeaders() {
+  llvm::StringSet<> NewAllHeaders;
+  {
+    shared_lck SharedAccessToPCH(PCHLock);
+    for (auto const &I : PCHs) {
+      auto const &Headers = I->Includes.allHeaders();
+      NewAllHeaders.insert(Headers.begin(), Headers.end());
+      NewAllHeaders.insert(I->CompileCommand.Filename);
+    }
+  }
+
+  std::unique_lock<std::shared_timed_mutex> ExclusiveAccessToAllHeaders(
+      UsedHeadersLock);
+  AllUsedHeaders = std::move(NewAllHeaders);
+}
+
+PCHQueue::Task PCHManager::announcedPCHTask(
+    const std::vector<tooling::CompileCommand> &PCHAnnounced) {
+  PCHQueue::Task T([this, PCHAnnounced] {
+    if (!Initialized)
+      log("(PCH) initializing ({0} announced)", PCHAnnounced.size());
+    analyzePCHDependencies(std::move(PCHAnnounced));
+
+    //at this point various findPCH calls are allowed
+    //to find their PCHs and wait for them to be built
+    if (!Initialized) {
+      Initialized = true;
+      InitCV.notify_all();
+    }
+
+    rebuildInvalidatedPCH((unsigned)PCHs.size(), FSType());
+    log("(PCH) updated after announce");
+    updateAllHeaders();
+  });
+
+  T.ThreadPri = llvm::ThreadPriority::Default;
+  return T;
+}
+
+llvm::StringRef findPCHDependency(const tooling::CompileCommand &CC,
+                                  size_t StartFromArg = 0, size_t N = std::string::npos) {
+  auto beg = CC.CommandLine.begin() + StartFromArg;
+  auto _end = N != std::string::npos ? beg + N : CC.CommandLine.end();
+  for (auto i = beg; i != _end; ++i) {
+    const auto &Arg = *i;
+    size_t P = 0;
+    while ((P = Arg.find("-include", P)) != std::string::npos) {
+      if (!P || Arg[P - 1] == '-' ||
+          Arg[P - 1] == ' ') // might be -include or --include
+      {
+        P += sizeof("-include") - 1;
+        if (Arg[P] == '=')
+          ++P; // skip =
+        size_t FileStart = P;
+        while ((P = Arg.find_first_of(' ', P)) != std::string::npos) {
+          if (Arg[P - 1] != '\\')
+            break;
+          ++P;
+        }
+        if (P == std::string::npos)
+          P = Arg.size();
+        return llvm::StringRef(Arg.data() + FileStart, P - FileStart);
+      }
+      ++P;
+    }
+  }
+  return {};
+}
+
+llvm::StringRef findDynamicPCH(const tooling::CompileCommand &CC) {
+  auto beg = CC.CommandLine.begin();
+  auto _end = CC.CommandLine.end();
+  for (auto i = beg; i != _end; ++i) {
+    const auto &Arg = *i;
+    if (Arg.find("__CLANGD_DYNAMIC_PCH__") != std::string::npos &&
+        (i + 1 != _end)) {
+      // next is expected to be the --include option
+      return findPCHDependency(CC, std::distance(beg, i) + 1, 1);
+    }
+  }
+  return {};
+}
+
+void PCHManager::analyzePCHDependencies(
+    std::vector<tooling::CompileCommand> PCHCommands) {
+  {
+    // clear dynamics is easy and safe due to shared_ptr
+    uniq_lck DynLoc(DynamicPCHLock);
+    DynamicPCHs.clear();
+  }
+
+  uniq_lck ExclusiveAccessToPCH(PCHLock);
+  // need to invalidate everything
+  for (auto &I : PCHs)
+    I->invalidate(ExclusiveAccessToPCH, true);//here we DO need to wait till usage is over
+
+  // removing
+  PCHs.clear();
+  PCHs.reserve(PCHCommands.size());
+  // 1. partiion PCH's with no dependencies
+  auto Beg = PCHCommands.begin();
+  auto End = PCHCommands.end();
+  auto NoDepIt = std::partition(PCHCommands.begin(), PCHCommands.end(),
+                                [](const tooling::CompileCommand &CC) {
+                                  return findPCHDependency(CC).empty();
+                                });
+  for (auto J = PCHCommands.begin(); J != NoDepIt; ++J)
+    PCHs.emplace_back(std::make_unique<PCHItem>(*J));
+
+  // 2. partition the rest till nothing is left
+  auto PrevPartBeg = Beg;
+  auto PartBeg = NoDepIt;
+  auto NewPartEnd = NoDepIt;
+  while (NewPartEnd != End) {
+    NewPartEnd =
+        std::partition(PartBeg, End, [&](const tooling::CompileCommand &CC) {
+          llvm::StringRef DepFName = findPCHDependency(CC);
+          // partition to the left if this dependency is among previously
+          // partitioned commands
+          return std::find_if(PrevPartBeg, PartBeg,
+                              [&](const tooling::CompileCommand &XX) {
+                                return XX.Filename == DepFName;
+                              }) != PartBeg;
+        });
+
+    for (auto J = PartBeg; J != NewPartEnd; ++J) {
+      PCHs.emplace_back(std::make_unique<PCHItem>(*J));
+
+      llvm::StringRef DepFName = findPCHDependency(*J);
+      // translate range for pchCommands into pchs
+      auto PCHsRangeBeg = PCHs.begin() + std::distance(Beg, PrevPartBeg);
+      auto PCHsRangeEnd = PCHs.begin() + std::distance(Beg, PartBeg);
+      // find the same PCHItem there
+      auto Dep = std::find_if(PCHsRangeBeg, PCHsRangeEnd,
+                              [&](const std::unique_ptr<PCHItem> &XX) {
+                                return XX->CompileCommand.Filename == DepFName;
+                              });
+      (*Dep)->DependOnMe.push_back(&*(PCHs.back()));
+      PCHs.back()->IdependOn.push_back(&(**Dep));
+    }
+
+    PrevPartBeg = PartBeg;
+    PartBeg = NewPartEnd;
+  }
+}
+
+unsigned PCHManager::PCHItem::invalidate(uniq_lck &Lock, bool WaitForNoUsage) {
+  unsigned Res = 0;
+  if (ItemState != PCHItem::State::Rebuild) {
+    ++Res;
+    if (WaitForNoUsage && (ItemState == PCHItem::State::Valid) && (InUse > 0))
+      CV.wait(Lock, [&] { return InUse == 0; });
+
+    ItemState = PCHItem::State::Rebuild;
+    ++Version;
+    // all dependencies must be invalidated
+    for (PCHItem *Dep : DependOnMe)
+      Res += Dep->invalidate(Lock, WaitForNoUsage);
+  }
+  return Res;
+}
+
+unsigned PCHManager::invalidateAffectedPCH(
+    const std::vector<std::string> &ChangedFiles) {
+  unsigned Invalidated = 0;
+  {
+    uniq_lck ExclusiveAccessToPCH(PCHLock);
+    llvm::StringSet<> ChangedU;
+    llvm::StringSet<> ChangedL;
+    for (auto S : ChangedFiles) {
+      S[0] = std::toupper(S[0]);
+      ChangedU.insert(S);
+      S[0] = std::tolower(S[0]);
+      ChangedL.insert(S);
+    }
+    for (auto &UI : PCHs) {
+      PCHItem &Item = *UI;
+      if (Item.ItemState == PCHItem::State::Rebuild)
+        continue;
+
+      if (ChangedU.contains(Item.CompileCommand.Filename) ||
+          ChangedL.contains(Item.CompileCommand.Filename)) {
+        log("(PCH) invalidating {0} and all dependendents",
+            Item.CompileCommand.Filename);
+        Invalidated += Item.invalidate(ExclusiveAccessToPCH, false);//don't have to wait due to shared_ptr model of PCHData
+        continue;
+      }
+
+      for (const auto &S : Item.Includes.allHeaders()) {
+        if (ChangedU.contains(S) || ChangedL.contains(S)) {
+          log("(PCH) invalidating {0} and all dependendents because"
+              " of the included (possible indirectly) {1} has changed",
+              Item.CompileCommand.Filename, S);
+          Invalidated += Item.invalidate(ExclusiveAccessToPCH, false);//don't have to wait due to shared_ptr model of PCHData
+          break;
+        }
+      }
+    }
+  }
+
+  {
+    shared_lck DynLock(DynamicPCHLock);
+    for (auto &I : DynamicPCHs) {
+      PCHItem &Item = *I.second;
+      if (Item.ItemState == PCHItem::State::Rebuild)
+        continue;
+
+      if (Item.IdependOn[0]->ItemState == PCHItem::State::Rebuild) {
+        Item.ItemState = PCHItem::State::Rebuild;
+        ++Item.Version;
+      }
+    }
+  }
+  return Invalidated;
+}
+
+bool PCHManager::tryAddDynamicPCH(tooling::CompileCommand const &Cmd, FSType FS) {
+  StringRef PCHDep = findPCHDependency(Cmd);
+  StringRef DynPCH = findDynamicPCH(Cmd);
+  if ((DynPCH.empty() || PCHDep.empty()) || (DynPCH == PCHDep))
+    return false;
+
+  {
+    shared_lck Lock(DynamicPCHLock);
+    if (DynamicPCHs.find(Cmd.Filename) != DynamicPCHs.end()) // already in there
+      return true;
+  }
+
+  PCHAccess depAccess = findPCH(PCHDep);
+  if (!depAccess)
+    return false;
+
+  {
+    uniq_lck Lock(DynamicPCHLock);
+    auto CC = Cmd;
+    CC.Filename = DynPCH.str();//actual compile command must be provided in compile commands database
+    auto Item = std::make_shared<PCHItem>(CC);
+    Item->IdependOn.push_back(const_cast<PCHItem*>(depAccess.Item));
+    Item->Dynamic = true;
+    DynamicPCHs[Cmd.Filename] = Item;
+    log("(DynPCH) added dynamic PCH {0} for {1}", DynPCH, Cmd.Filename);
+    Queue.push(PCHQueue::Task([this, FS] { rebuildInvalidatedPCH(1, FS); }));
+  }
+
+  return true;
+}
+
+bool PCHManager::tryRemoveDynamicPCH(tooling::CompileCommand const &Cmd) {
+  StringRef PCHDep = findPCHDependency(Cmd);
+  StringRef DynPCH = findDynamicPCH(Cmd);
+  if ((DynPCH.empty() || PCHDep.empty()) || (DynPCH == PCHDep))
+    return false;
+
+  uniq_lck Lock(DynamicPCHLock); 
+
+  if (DynamicPCHs.erase(Cmd.Filename) == 1) {
+    log("(DynPCH) removed dynamic PCH {0} for {1}", DynPCH, Cmd.Filename);
+    return true;
+  }
+  return false;
+}
+
+IntrusiveRefCntPtr<llvm::vfs::FileSystem>
+PCHManager::addDependencies(const PCHItem *Dep,
+                            IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS, 
+                            UsedPCHDataList &pchdatas) {
+  IntrusiveRefCntPtr<llvm::vfs::InMemoryFileSystem> PCHFS(
+      new llvm::vfs::InMemoryFileSystem());
+  while (Dep) {
+    auto data = std::atomic_load(&Dep->PCHData);
+    if (data) {
+		pchdatas.emplace_back(data);
+		auto Buf = llvm::MemoryBuffer::getMemBuffer(*data);
+		PCHFS->addFile(Dep->CompileCommand.Filename + ".pch", 0, std::move(Buf));
+		Dep = Dep->IdependOn.empty() ? nullptr : Dep->IdependOn[0];
+    }else {
+      elog("(PCH) empty data on dependency {0}!!! (Status: {1})", Dep->CompileCommand.Filename, (int)Dep->ItemState);
+    }
+  }
+
+  IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> Overlay(
+      new llvm::vfs::OverlayFileSystem(VFS));
+
+  Overlay->pushOverlay(PCHFS);
+  return Overlay;
+}
+
+void PCHManager::rebuildPCH(PCHItem &Item, FSType FS) {
+  auto S = PCHItem::State::Invalid;
+  auto OnExit = llvm::make_scope_exit([&] {
+    if (OnProgress)
+      OnProgress(Stats{++Complete, Total});
+    Item.ItemState = S;
+    Item.CV.notify_all();
+    OnPCHBuilt.broadcast(
+        PCHEvent{Item.CompileCommand.Filename, S == PCHItem::State::Valid});
+  });
+
+  PCHItem *Dep = Item.IdependOn.empty() ? nullptr : Item.IdependOn[0];
+  if (Dep && Dep->ItemState == PCHItem::State::Rebuild) {
+    elog("(PCH)Cannot rebuild PCH for {0} as it depends on {1} which is "
+         "in rebuild state",
+         Item.CompileCommand.Filename, Dep->CompileCommand.Filename);
+    
+    shared_lck Lock(PCHLock);
+    Dep->CV.wait(Lock, [&] { return Dep->ItemState != PCHItem::State::Rebuild; });
+  }
+  if (Dep && Dep->ItemState != PCHItem::State::Valid) {
+    elog("(PCH)Cannot rebuild PCH for {0} as it depends on {1} which is "
+         "invalid",
+         Item.CompileCommand.Filename, Dep->CompileCommand.Filename);
+    return;
+  }
+  ParseOptions Opts;
+
+  ParseInputs Inputs;
+  Inputs.TFS = &TFS;
+
+  // auto FS = TFS.view(item.CompileCommand.Directory);
+  // FS->getBufferForFile(getAbsolutePath(item.CompileCommand));
+  // Inputs.Contents = TFS;
+
+  auto CC = CDB.getCompileCommand(Item.CompileCommand.Filename);
+  if (!CC) {
+    elog("(PCH)Failed to get compile command for {0}",
+         Item.CompileCommand.Filename);
+    return;
+  }
+
+  Inputs.ForceRebuild = true;
+  Inputs.Opts = std::move(Opts);
+  Inputs.CompileCommand = *CC;
+
+  StoreDiags CompilerInvocationDiagConsumer;
+  std::vector<std::string> CC1Args;
+
+  std::unique_ptr<CompilerInvocation> Invocation =
+      buildCompilerInvocation(Inputs, CompilerInvocationDiagConsumer, &CC1Args);
+  if (!CC1Args.empty())
+    log("(PCH)Driver produced command: cc1 {0}", printArgv(CC1Args));
+
+  auto &PreprocessorOpts = Invocation->getPreprocessorOpts();
+  PreprocessorOpts.PrecompiledPreambleBytes.first = 0;
+  PreprocessorOpts.PrecompiledPreambleBytes.second = false;
+  PreprocessorOpts.DisablePCHOrModuleValidation =
+      DisableValidationForModuleKind::PCH;
+  PreprocessorOpts.WriteCommentListToPCH = false;
+  //PreprocessorOpts.GeneratePreamble = true;
+
+  auto VFS = TFS.view(Item.CompileCommand.Directory);
+  if (FS) {
+    log("(PCH) using passed FS as overlay");
+    IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> Overlay(
+        new llvm::vfs::OverlayFileSystem(VFS)); // passed VFS is primary
+    Overlay->pushOverlay(FS);                 // FS is secondary
+    VFS = Overlay;
+  }
+
+  UsedPCHDataList UsedPCHDatas;
+  if (Dep) {
+    PreprocessorOpts.ImplicitPCHInclude =
+        std::string(Dep->CompileCommand.Filename) + ".pch";
+    VFS = addDependencies(Dep, VFS, UsedPCHDatas);
+  }
+
+  CppFilePreambleCallbacks SerializedDeclsCollector(
+      Item.CompileCommand.Filename,
+      [&](ASTContext &AST, std::shared_ptr<clang::Preprocessor> PP,
+          const CanonicalIncludes &CanInc) {
+        // call Callback.onPreambleAST
+        Callbacks.onPreambleAST(Item.CompileCommand.Filename, std::to_string(Item.Version), AST,
+                                std::move(PP), CanInc);
+      });
+  PreambleCallbacks &Callbacks = SerializedDeclsCollector;
+  llvm::SmallString<32> AbsFileName(Item.CompileCommand.Filename);
+  VFS->makeAbsolute(AbsFileName);
+  auto StatCache = std::make_unique<PreambleFileStatusCache>(AbsFileName);
+
+  FrontendOptions &FrontendOpts = Invocation->getFrontendOpts();
+  FrontendOpts.ProgramAction = frontend::GeneratePCH;
+  FrontendOpts.SkipFunctionBodies = true;
+  //FrontendOpts.OutputFile = "__in__memory___";
+
+  std::vector<std::unique_ptr<FeatureModule::ASTListener>> ASTListeners;
+  if (Inputs.FeatureModules) {
+    for (auto &M : *Inputs.FeatureModules) {
+      if (auto Listener = M.astListeners())
+        ASTListeners.emplace_back(std::move(Listener));
+    }
+  }
+  StoreDiags PreambleDiagnostics;
+  PreambleDiagnostics.setDiagCallback(
+      [&ASTListeners, &Item](const clang::Diagnostic &D, clangd::Diag &Diag) {
+        if (Diag.Severity >= DiagnosticsEngine::Level::Error) {
+          // scream here
+          elog("Error while building PCH for {0}: {1}",
+               Item.CompileCommand.Filename, Diag.Message);
+        }
+        llvm::for_each(ASTListeners,
+                       [&](const auto &L) { L->sawDiagnostic(D, Diag); });
+      });
+  llvm::IntrusiveRefCntPtr<DiagnosticsEngine> PreambleDiagsEngine =
+      CompilerInstance::createDiagnostics(&Invocation->getDiagnosticOpts(),
+                                          &PreambleDiagnostics, false);
+
+  std::shared_ptr<PCHContainerOperations> PCHContainerOps =
+      std::make_shared<PCHContainerOperations>();
+
+  // Create the compiler instance to use for building the precompiled preamble.
+  std::unique_ptr<CompilerInstance> Clang(
+      new CompilerInstance(std::move(PCHContainerOps)));
+
+  // Recover resources if we crash before exiting this method.
+  llvm::CrashRecoveryContextCleanupRegistrar<CompilerInstance> CICleanup(
+      Clang.get());
+
+  Clang->setInvocation(std::move(Invocation));
+  Clang->setDiagnostics(&*PreambleDiagsEngine);
+  if (!Clang->createTarget()) {
+    elog("(PCH)Failed to create clang traget for {0}",
+         Item.CompileCommand.Filename);
+    return; // BuildPreambleError::CouldntCreateTargetInfo;
+  }
+
+  if (Clang->getFrontendOpts().Inputs.size() != 1 ||
+      Clang->getFrontendOpts().Inputs[0].getKind().getFormat() !=
+          InputKind::Source ||
+      Clang->getFrontendOpts().Inputs[0].getKind().getLanguage() ==
+          Language::LLVM_IR) {
+    elog("(PCH)Bad inputs for {0}", Item.CompileCommand.Filename);
+    return; // BuildPreambleError::BadInputs;
+  }
+
+  // Create a file manager object to provide access to and cache the filesystem.
+  Clang->setFileManager(new FileManager(Clang->getFileSystemOpts(), VFS));
+
+  // Create the source manager.
+  Clang->setSourceManager(
+      new SourceManager(*PreambleDiagsEngine, Clang->getFileManager()));
+
+  Clang->getLangOpts().CompilingPCH = true;
+
+  std::shared_ptr<std::string> newPCH = std::make_shared<std::string>();
+  std::unique_ptr<PrecompilePCHAction> Act;
+  Act.reset(new PrecompilePCHAction(&*newPCH, Callbacks));
+  Callbacks.BeforeExecute(*Clang);
+  if (!Act->BeginSourceFile(*Clang.get(), Clang->getFrontendOpts().Inputs[0])) {
+    elog("(PCH)Failed to start processing {0}", Item.CompileCommand.Filename);
+    return; // BuildPreambleError::BeginSourceFileFailed;
+  }
+
+  std::unique_ptr<PPCallbacks> DelegatedPPCallbacks =
+      Callbacks.createPPCallbacks();
+  if (DelegatedPPCallbacks)
+    Clang->getPreprocessor().addPPCallbacks(std::move(DelegatedPPCallbacks));
+  if (auto *CommentHandler = Callbacks.getCommentHandler())
+    Clang->getPreprocessor().addCommentHandler(CommentHandler);
+
+  if (llvm::Error Err = Act->Execute()) {
+    elog("(PCH)Failure while executing clang for {0}: {1}",
+         Item.CompileCommand.Filename,
+         errorToErrorCode(std::move(Err)).message());
+    return;
+  }
+
+  // Run the callbacks.
+  Callbacks.AfterExecute(*Clang);
+
+  Act->EndSourceFile();
+
+  if (!Act->hasEmittedPreamblePCH()) {
+    elog("(PCH)Could not emmit PCH for {0} (Version: {1})", Item.CompileCommand.Filename, Item.Version);
+    return;
+  }
+
+  Item.Includes = SerializedDeclsCollector.takeIncludes();
+  Item.CanonIncludes = SerializedDeclsCollector.takeCanonicalIncludes();
+  std::atomic_store(&Item.PCHData, newPCH);
+  S = PCHItem::State::Valid;
+  log("(PCH)Successfully generated precompiled header of size: {0} (file: {1}; Version: {2})",
+      Item.PCHData->size(), Item.CompileCommand.Filename, Item.Version);
+}
+
+void PCHManager::rebuildInvalidatedPCH(unsigned Total, FSType FS) {
+  Complete = 0;
+  this->Total = Total;
+  if (OnProgress) OnProgress(Stats{Complete, Total});
+  std::vector<std::thread> Builders;
+  Builders.reserve(PCHs.size() + DynamicPCHs.size());
+  for (auto &I : PCHs) {
+    if (I->ItemState == PCHItem::State::Rebuild) {
+      //rebuildPCH(*I, FS);
+      Builders.emplace_back(
+          [this,It=&*I,FS]() {
+            rebuildPCH(*It, FS);
+          }
+      );
+    }
+  }
+
+  {
+    shared_lck DynLock(DynamicPCHLock);
+
+    for (auto &I : DynamicPCHs) {
+      if (I.second->ItemState == PCHItem::State::Rebuild) {
+        Builders.emplace_back(
+            [this, It = I.second, FS]() { rebuildPCH(*It.get(), FS); });
+      }
+    }
+  }
+
+  for(auto &T : Builders)
+    T.join();
+}
+
+PCHManager::PCHAccess
+PCHManager::tryFindPCH(tooling::CompileCommand const &Cmd) const {
+  if (!Initialized && !WaitForInit) {
+    log("(tryFindPCH) is not initialized yet. Return empty for {0}", Cmd.Filename);
+    return {};
+  }
+  return findPCH(Cmd);
+}
+
+PCHManager::PCHAccess PCHManager::tryFindDynPCH(tooling::CompileCommand const& Cmd) const {
+  if (!Initialized && !WaitForInit) {
+    log("(tryFindDynPCH) is not initialized yet. Return empty for {0}", Cmd.Filename);
+    return {};
+  }
+  return findPCH(Cmd);
+}
+
+PCHManager::PCHAccess
+PCHManager::tryFindPCH(clang::clangd::PathRef PCHFile) const {
+  if (!Initialized && !WaitForInit) {
+    log("(findPCH) is not initialized yet. Return empty for {0}", PCHFile);
+    return {};
+  }
+  return findPCH(PCHFile);
+}
+
+bool PCHManager::hasPCHInDependencies(tooling::CompileCommand const& Cmd, PathRef PCHFile) const {
+  StringRef DynPCH = findDynamicPCH(Cmd);
+  if (!DynPCH.empty() && (DynPCH == PCHFile)) {
+    shared_lck Lock(DynamicPCHLock);
+    log("(PCH) hasPCHInDependencies request for {0} (PCH in question: {1}); "
+        "Looking among dynamics",
+        Cmd.Filename, PCHFile);
+    for (const auto &I : DynamicPCHs) {
+      if (I.second->CompileCommand.Filename == PCHFile) {
+        log("(PCH) hasPCHInDependencies: found for {0} (PCH in question: {1}) "
+            "among dynamics",
+            Cmd.Filename, PCHFile);
+        return true;
+      }
+    }
+  }
+  llvm::StringRef Dep = findPCHDependency(Cmd);
+  if (!Dep.empty()) {
+    shared_lck Lock(PCHLock);
+    log("(PCH) hasPCHInDependencies request for {0} (PCH in question: {1})",
+        Cmd.Filename, PCHFile);
+
+    for (const auto &I : PCHs) {
+      if (I->CompileCommand.Filename == Dep) {
+        if (I->CompileCommand.Filename == PCHFile) // reacting only on main
+        {
+          log("(PCH) hasPCHInDependencies: found for {0} (PCH in question: "
+              "{1})",
+              Cmd.Filename, PCHFile);
+          return true;
+        }
+        /*
+        const PCHItem *pI = &*I;
+        while (pI) {
+          if (pI->CompileCommand.Filename == PCHFile) {
+            return true;
+          }
+          pI = pI->IdependOn.empty() ? nullptr : pI->IdependOn[0];
+        }
+        */
+      }
+    }
+  }
+  return false;
+}
+
+PCHManager::PCHAccess
+PCHManager::findPCH(tooling::CompileCommand const &Cmd) const {
+  // return {};
+  /* if (llvm::StringRef(Cmd.Filename).endswith(".h"))
+  {
+    log("(findPCH) turned off for headers. {0}", Cmd.Filename);
+    return {};
+  }*/
+  StringRef DynPCH = findDynamicPCH(Cmd);
+  if (!DynPCH.empty()) {
+    auto pchAccess = findDynPCH(DynPCH);
+    if (pchAccess)
+      return pchAccess;
+  }
+
+  llvm::StringRef Dep = findPCHDependency(Cmd);
+  if (!Dep.empty())
+    return findPCH(Dep);
+  return {};
+}
+
+PCHManager::PCHAccess
+PCHManager::findDynPCH(clang::clangd::PathRef PCHFile) const {
+  if (!Initialized) {
+    log("(findPCH) is not initialized yet. Waiting for initialization...");
+    shared_lck Lock(PCHLock);
+    InitCV.wait(Lock, [&] { return Initialized.load(); });
+  }
+  shared_lck Lock(DynamicPCHLock);
+  vlog("(findDynamicPCH) find request for {0}", PCHFile);
+  for (const auto &It : DynamicPCHs) {
+    auto I = It.second;
+    if (I->CompileCommand.Filename == PCHFile) {
+      if (I->ItemState == PCHItem::State::Rebuild) {
+        auto data = std::atomic_load(&I->PCHData);
+        if (data->empty()) // if it's empty - we wait. If there's some old PCH -
+                           // we use it right away to avoid delays
+          I->CV.wait(Lock,
+                     [&] { return I->ItemState != PCHItem::State::Rebuild; });
+      }
+
+      if (I->ItemState == PCHItem::State::Invalid)
+        return {};
+
+      vlog("(findDynamicPCH) found request for {0}", PCHFile);
+      return PCHAccess(I);
+    }
+  }
+  return {};
+}
+
+PCHManager::PCHAccess
+PCHManager::findPCH(clang::clangd::PathRef PCHFile) const {
+  // return {};
+  if (!Initialized) {
+    log("(findPCH) is not initialized yet. Waiting for initialization...");
+    shared_lck Lock(PCHLock);
+    InitCV.wait(Lock, [&] { return Initialized.load(); });
+  }
+  shared_lck Lock(PCHLock);
+  vlog("(findPCH) find request for {0}", PCHFile);
+
+  for (const auto &I : PCHs) {
+    if (I->CompileCommand.Filename == PCHFile) {
+      if (I->ItemState == PCHItem::State::Rebuild) {
+        auto data = std::atomic_load(&I->PCHData);
+        if (data->empty())//if it's empty - we wait. If there's some old PCH - we use it right away to avoid delays
+			I->CV.wait(Lock, [&] { return I->ItemState != PCHItem::State::Rebuild; });
+      }
+
+      if (I->ItemState == PCHItem::State::Invalid)
+        return {};
+
+      vlog("(findPCH) found request for {0}", PCHFile);
+      return PCHAccess(I.get());
+    }
+  }
+  return {};
+}
+
+// PCHManager::PCHAccess
+bool PCHManager::PCHAccess::addPCH(
+    CompilerInvocation *CI,
+    IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS) const {
+  if (Item) {
+    auto &pp = CI->getPreprocessorOpts();
+    pp.AllowPCHWithCompilerErrors = true;
+    pp.DisablePCHOrModuleValidation =
+        DisableValidationForModuleKind::PCH;
+    pp.ImplicitPCHInclude =
+        std::string(Item->CompileCommand.Filename) + ".pch";
+    VFS = addDependencies(Item, VFS, UsedPCHDatas);
+    return true;
+  }
+  return false;
+}
+
+PCHManager::PCHAccess::PCHAccess(const PCHItem *Item) : Item(Item) {
+  if (Item)
+    ++Item->InUse;
+}
+
+PCHManager::PCHAccess::PCHAccess(std::shared_ptr<PCHItem> ShItem)
+    : Item(ShItem.get()), DynItem(ShItem) {
+  if (Item) {
+    ++Item->InUse;
+  }
+}
+
+PCHManager::PCHAccess::PCHAccess(PCHAccess &&Rhs) : DynItem(std::move(Rhs.DynItem)), Item(Rhs.Item), UsedPCHDatas(std::move(Rhs.UsedPCHDatas)) {
+  Rhs.Item = nullptr;
+}
+PCHManager::PCHAccess::~PCHAccess() {
+  if (Item && (Item->InUse.fetch_sub(1) == 1))
+    Item->CV.notify_all();
+}
+
+PCHManager::PCHAccess &PCHManager::PCHAccess::operator=(PCHAccess &&Rhs) {
+  std::swap(Item, Rhs.Item);
+  UsedPCHDatas = std::move(Rhs.UsedPCHDatas);
+  DynItem = std::move(Rhs.DynItem);
+  return *this;
+}
+
+} // namespace clangd
+} // namespace clang
\ No newline at end of file
diff --git a/clang-tools-extra/clangd/PCHManager.h b/clang-tools-extra/clangd/PCHManager.h
new file mode 100644
index 000000000000..bb57c5485605
--- /dev/null
+++ b/clang-tools-extra/clangd/PCHManager.h
@@ -0,0 +1,237 @@
+#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PCHMANAGER_H
+#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PCHMANAGER_H
+
+#include "Headers.h"
+#include "Compiler.h"
+#include "Diagnostics.h"
+#include "GlobalCompilationDatabase.h"
+#include "index/CanonicalIncludes.h"
+#include "support/Function.h"
+#include "support/MemoryTree.h"
+#include "support/Path.h"
+#include "support/Threading.h"
+#include "clang/Frontend/CompilerInvocation.h"
+#include "clang/Tooling/CompilationDatabase.h"
+#include "llvm/ADT/Optional.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Support/Threading.h"
+#include <chrono>
+#include <memory>
+#include <shared_mutex>
+
+namespace clang {
+namespace clangd {
+
+class ParsingCallbacks;
+
+unsigned getDefaultAsyncThreadsCount();
+
+//Queue for PCH
+class PCHQueue {
+public:
+  /// A work item on the thread pool's queue.
+  struct Task {
+    explicit Task(std::function<void()> Run) : Run(std::move(Run)) {}
+
+    std::function<void()> Run;
+    llvm::ThreadPriority ThreadPri = llvm::ThreadPriority::Background;
+    unsigned QueuePri = 0; // Higher-priority tasks will run first.
+
+    bool operator<(const Task &O) const { return QueuePri < O.QueuePri; }
+  };
+
+  // Describes the number of tasks processed by the queue.
+  struct Stats {
+    unsigned Enqueued = 0;  // Total number of tasks ever enqueued.
+    unsigned Active = 0;    // Tasks being currently processed by a worker.
+    unsigned Completed = 0; // Tasks that have been finished.
+    unsigned LastIdle = 0;  // Number of completed tasks when last empty.
+  };
+
+  PCHQueue(std::function<void(Stats)> OnProgress = nullptr)
+      : OnProgress(OnProgress) {}
+
+  // Add tasks to the queue.
+  void push(Task);
+  void append(std::vector<Task>);
+
+  // Process items on the queue until the queue is stopped.
+  // If the queue becomes empty, OnIdle will be called (on one worker).
+  void work(std::function<void()> OnIdle = nullptr);
+
+  // Stop processing new tasks, allowing all work() calls to return soon.
+  void stop();
+private:
+  void notifyProgress() const; // Requires lock Mu
+  bool adjust(Task &T);
+
+  std::mutex Mu;
+  Stats Stat;
+  std::condition_variable CV;
+  bool ShouldStop = false;
+  std::vector<Task> Queue; // max-heap
+  std::function<void(Stats)> OnProgress;
+};
+
+class PCHManager {
+    using uniq_lck = std::unique_lock<std::shared_timed_mutex>;
+    struct PCHItem
+    {
+      enum class State {Valid, Rebuild, Invalid};
+
+        PCHItem(tooling::CompileCommand CC): CompileCommand(std::move(CC)), PCHData(std::make_shared<std::string>()) {}
+        unsigned invalidate(uniq_lck &Lock, bool WaitForNoUsage);
+
+        tooling::CompileCommand CompileCommand;
+        std::shared_ptr<std::string> PCHData;
+        std::vector<PCHItem*> DependOnMe;
+        std::vector<PCHItem*> IdependOn;
+        IncludeStructure Includes;
+        CanonicalIncludes CanonIncludes;
+        State ItemState = State::Rebuild;
+        int Version = 0;
+        bool Dynamic = false;
+        mutable std::atomic<unsigned> InUse{0};
+        mutable std::condition_variable_any CV;
+    };
+public:
+  struct Stats {
+    unsigned Completed = 0; // PCHs generated
+    unsigned Total = 0;     // Total amount of PCHs
+  };
+
+  struct Options {
+    /// Cache (large) pch data in RAM rather than temporary files on disk.
+    bool StorePCHInMemory = true;
+    bool WaitForInit = true;
+    std::function<void(Stats)> OnProgress;
+  };
+
+  using shared_lck = std::shared_lock<std::shared_timed_mutex>;
+  using UsedPCHDataList = std::vector<std::shared_ptr<std::string>>;
+  struct PCHEvent {
+    PathRef PCHPath;
+    bool Success;
+  };
+  using PCHBuiltEvent = Event<PCHEvent>;
+
+  PCHManager(const GlobalCompilationDatabase &CDB, const ThreadsafeFS &TFS, ParsingCallbacks &Callbacks, const Options &Opts);
+  ~PCHManager();
+
+  class PCHAccess 
+  {
+  public:
+    PCHAccess() = default;
+    PCHAccess(const PCHAccess &) = delete;
+    PCHAccess(PCHAccess &&);
+    ~PCHAccess();
+
+    PCHAccess& operator=(const PCHAccess &) = delete;
+    PCHAccess& operator=(PCHAccess &&);
+
+    bool addPCH(CompilerInvocation *CI, IntrusiveRefCntPtr<llvm::vfs::FileSystem> &VFS) const;
+    llvm::StringRef filename() const {return Item->CompileCommand.Filename;}
+    auto version() const { return Item->Version; }
+
+    operator bool() const { return Item != nullptr; }
+  private:
+    PCHAccess(const PCHItem *Item);
+    PCHAccess(std::shared_ptr<PCHItem> ShItem);
+
+   std::shared_ptr<PCHItem> DynItem;
+    const PCHItem *Item = nullptr;
+    mutable UsedPCHDataList UsedPCHDatas;
+    friend class PCHManager;
+  };
+
+  using FSType = llvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>;
+
+  void checkChangedFile(PathRef File, FSType FS);
+
+  PCHAccess findPCH(tooling::CompileCommand const& Cmd) const;
+  PCHAccess findPCH(clang::clangd::PathRef PCHFile) const;
+  PCHAccess findDynPCH(clang::clangd::PathRef PCHFile) const;
+
+  PCHAccess tryFindPCH(tooling::CompileCommand const& Cmd) const;
+  PCHAccess tryFindDynPCH(tooling::CompileCommand const& Cmd) const;
+  PCHAccess tryFindPCH(clang::clangd::PathRef PCHFile) const;
+
+  bool hasPCHInDependencies(tooling::CompileCommand const& Cmd, PathRef PCHFile) const;
+
+  PCHBuiltEvent::Subscription watch(PCHBuiltEvent::Listener L) const {
+    return OnPCHBuilt.observe(std::move(L));
+  }
+
+  bool tryAddDynamicPCH(tooling::CompileCommand const &Cmd, FSType FS);
+  bool tryRemoveDynamicPCH(tooling::CompileCommand const &Cmd);
+
+  private:
+    void enqueue(const std::vector<std::string> &ChangedFiles, FSType FS) {
+        Queue.push(changedFilesTask(ChangedFiles, FS));
+    }
+
+    void enqueue(const std::vector<tooling::CompileCommand> &AnnouncedPCHs) {
+        Queue.push(announcedPCHTask(AnnouncedPCHs));
+    }
+
+    PCHQueue::Task
+    checkChangedPeriodically();
+
+    PCHQueue::Task
+    changedFilesTask(const std::vector<std::string> &ChangedFiles, FSType FS);
+
+    PCHQueue::Task
+    announcedPCHTask(const std::vector<tooling::CompileCommand> &AnnouncedPCHs);
+
+    void analyzePCHDependencies(std::vector<tooling::CompileCommand> PCHCommands);
+    unsigned invalidateAffectedPCH(const std::vector<std::string> &ChangedFiles);
+    void rebuildInvalidatedPCH(unsigned Tota, FSType FSl);
+    void updateAllHeaders();
+    void rebuildPCH(PCHItem &Item, FSType FS);
+
+    static IntrusiveRefCntPtr<llvm::vfs::FileSystem> addDependencies(const PCHItem *Dep, IntrusiveRefCntPtr<llvm::vfs::FileSystem> VFS, UsedPCHDataList &pchdatas);
+
+    using CDBWeak = std::weak_ptr<const tooling::CompilationDatabase>;
+    using PCHItemList = std::vector<std::unique_ptr<PCHItem>>;
+    using PCHSharedItemMap = std::unordered_map<std::string, std::shared_ptr<PCHItem>>;
+
+    const GlobalCompilationDatabase &CDB;
+    const ThreadsafeFS &TFS;
+    ParsingCallbacks &Callbacks;
+    std::function<void(Stats)> OnProgress;
+
+    PCHQueue Queue;
+    GlobalCompilationDatabase::CommandChanged::Subscription CommandsChanged;
+    GlobalCompilationDatabase::PCHAnnounce::Subscription PCHAnnounce;
+
+    bool WaitForInit = true;
+    std::atomic<bool> Initialized = {false};
+    mutable std::condition_variable_any InitCV;
+    PCHItemList PCHs;
+    mutable std::shared_timed_mutex PCHLock;
+    AsyncTaskRunner ThreadPool;
+
+    PCHSharedItemMap DynamicPCHs;
+    mutable std::shared_timed_mutex DynamicPCHLock;
+
+    using clock_t = std::chrono::steady_clock;
+    using time_point_t = std::chrono::time_point<clock_t>;
+    std::mutex ChangedMtx;
+    std::vector<std::string> Changed;
+    FSType ChangedFS;
+    time_point_t ChangedLastTime;
+
+    llvm::StringSet<> AllUsedHeaders;
+    mutable std::shared_timed_mutex UsedHeadersLock;
+
+    unsigned Total=0;
+    std::atomic<unsigned> Complete{0};
+
+    mutable PCHBuiltEvent OnPCHBuilt;
+};
+} // namespace clangd
+} // namespace clang
+
+#endif
\ No newline at end of file
diff --git a/clang-tools-extra/clangd/PCHManagerQueue.cpp b/clang-tools-extra/clangd/PCHManagerQueue.cpp
new file mode 100644
index 000000000000..0aa53208b541
--- /dev/null
+++ b/clang-tools-extra/clangd/PCHManagerQueue.cpp
@@ -0,0 +1,93 @@
+#include "PCHManager.h"
+#include "support/Logger.h"
+#include <memory>
+
+namespace clang {
+namespace clangd {
+
+void PCHQueue::notifyProgress() const {
+  dlog("Queue: {0}/{1} ({2} active). Last idle at {3}", Stat.Completed,
+       Stat.Enqueued, Stat.Active, Stat.LastIdle);
+  if (OnProgress)
+    OnProgress(Stat);
+}
+
+void PCHQueue::work(std::function<void()> OnIdle) {
+  while (true) {
+    llvm::Optional<Task> Task;
+    {
+      std::unique_lock<std::mutex> Lock(Mu);
+      CV.wait(Lock, [&] { return ShouldStop || !Queue.empty(); });
+      if (ShouldStop) {
+        Queue.clear();
+        CV.notify_all();
+        return;
+      }
+      ++Stat.Active;
+      std::pop_heap(Queue.begin(), Queue.end());
+      Task = std::move(Queue.back());
+      Queue.pop_back();
+      notifyProgress();
+    }
+
+    if (Task->ThreadPri != llvm::ThreadPriority::Default)
+      llvm::set_thread_priority(Task->ThreadPri);
+    Task->Run();
+    if (Task->ThreadPri != llvm::ThreadPriority::Default)
+      llvm::set_thread_priority(llvm::ThreadPriority::Default);
+
+    {
+      std::unique_lock<std::mutex> Lock(Mu);
+      ++Stat.Completed;
+      if (Stat.Active == 1 && Queue.empty()) {
+        // We just finished the last item, the queue is going idle.
+        assert(ShouldStop || Stat.Completed == Stat.Enqueued);
+        Stat.LastIdle = Stat.Completed;
+        if (OnIdle) {
+          Lock.unlock();
+          OnIdle();
+          Lock.lock();
+        }
+      }
+      assert(Stat.Active > 0 && "before decrementing");
+      --Stat.Active;
+      notifyProgress();
+    }
+    CV.notify_all();
+  }
+}
+
+void PCHQueue::stop() {
+  {
+    std::lock_guard<std::mutex> QueueLock(Mu);
+    ShouldStop = true;
+  }
+  CV.notify_all();
+}
+
+void PCHQueue::push(Task T) {
+  {
+    std::lock_guard<std::mutex> Lock(Mu);
+    Queue.push_back(std::move(T));
+    std::push_heap(Queue.begin(), Queue.end());
+    ++Stat.Enqueued;
+    notifyProgress();
+  }
+  CV.notify_all();
+}
+
+void PCHQueue::append(std::vector<Task> Tasks) {
+  {
+    std::lock_guard<std::mutex> Lock(Mu);
+    for (Task &T : Tasks) {
+      Queue.push_back(std::move(T));
+      ++Stat.Enqueued;
+    }
+    std::make_heap(Queue.begin(), Queue.end());
+    notifyProgress();
+  }
+  CV.notify_all();
+}
+
+} // namespace clangd
+} // namespace clang
diff --git a/clang-tools-extra/clangd/ParsedAST.cpp b/clang-tools-extra/clangd/ParsedAST.cpp
index 0d7e4631d660..9f07da45ad24 100644
--- a/clang-tools-extra/clangd/ParsedAST.cpp
+++ b/clang-tools-extra/clangd/ParsedAST.cpp
@@ -245,11 +245,24 @@ llvm::Optional<ParsedAST>
 ParsedAST::build(llvm::StringRef Filename, const ParseInputs &Inputs,
                  std::unique_ptr<clang::CompilerInvocation> CI,
                  llvm::ArrayRef<Diag> CompilerInvocationDiags,
-                 std::shared_ptr<const PreambleData> Preamble) {
+                 std::shared_ptr<const PreambleData> Preamble, PCHManager::PCHAccess *PCHAccess) {
   trace::Span Tracer("BuildAST");
   SPAN_ATTACH(Tracer, "File", Filename);
 
   auto VFS = Inputs.TFS->view(Inputs.CompileCommand.Directory);
+  if (Inputs.DraftFS) {
+    IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> Overlay(
+        new llvm::vfs::OverlayFileSystem(VFS)); 
+    Overlay->pushOverlay(Inputs.DraftFS);      
+    VFS = Overlay;
+  }
+  if (PCHAccess && *PCHAccess) 
+  {
+    Preamble = nullptr;
+    log("building AST for {0} and applying PCH {1} (Version {2})", Inputs.CompileCommand.Filename, PCHAccess->filename(), PCHAccess->version());
+    PCHAccess->addPCH(CI.get(), VFS);
+  }
+
   if (Preamble && Preamble->StatCache)
     VFS = Preamble->StatCache->getConsumingFS(std::move(VFS));
 
diff --git a/clang-tools-extra/clangd/ParsedAST.h b/clang-tools-extra/clangd/ParsedAST.h
index 703ae3825428..100953eb6faa 100644
--- a/clang-tools-extra/clangd/ParsedAST.h
+++ b/clang-tools-extra/clangd/ParsedAST.h
@@ -24,6 +24,7 @@
 #include "Compiler.h"
 #include "Diagnostics.h"
 #include "Headers.h"
+#include "PCHManager.h"
 #include "Preamble.h"
 #include "index/CanonicalIncludes.h"
 #include "support/Path.h"
@@ -55,7 +56,7 @@ public:
   build(llvm::StringRef Filename, const ParseInputs &Inputs,
         std::unique_ptr<clang::CompilerInvocation> CI,
         llvm::ArrayRef<Diag> CompilerInvocationDiags,
-        std::shared_ptr<const PreambleData> Preamble);
+        std::shared_ptr<const PreambleData> Preamble, PCHManager::PCHAccess *PCHAccess);
 
   ParsedAST(ParsedAST &&Other);
   ParsedAST &operator=(ParsedAST &&Other);
diff --git a/clang-tools-extra/clangd/Preamble.cpp b/clang-tools-extra/clangd/Preamble.cpp
index e003af6e0dfa..fce2c353902f 100644
--- a/clang-tools-extra/clangd/Preamble.cpp
+++ b/clang-tools-extra/clangd/Preamble.cpp
@@ -317,7 +317,7 @@ PreambleData::PreambleData(const ParseInputs &Inputs,
 std::shared_ptr<const PreambleData>
 buildPreamble(PathRef FileName, CompilerInvocation CI,
               const ParseInputs &Inputs, bool StoreInMemory,
-              PreambleParsedCallback PreambleCallback) {
+              PreambleParsedCallback PreambleCallback, const PCHManager *PCHMgr/* = nullptr*/) {
   // Note that we don't need to copy the input contents, preamble can live
   // without those.
   auto ContentsBuffer =
@@ -369,6 +369,14 @@ buildPreamble(PathRef FileName, CompilerInvocation CI,
   auto VFS = Inputs.TFS->view(Inputs.CompileCommand.Directory);
   llvm::SmallString<32> AbsFileName(FileName);
   VFS->makeAbsolute(AbsFileName);
+
+  PCHManager::PCHAccess PCH = PCHMgr ? PCHMgr->findPCH(Inputs.CompileCommand) : PCHManager::PCHAccess{};
+  if (PCH)
+  {
+    log("Applying PCH {0} to build preamble for {1}", PCH.filename(), FileName);
+    PCH.addPCH(&CI, VFS);
+  }
+
   auto StatCache = std::make_unique<PreambleFileStatusCache>(AbsFileName);
   auto BuiltPreamble = PrecompiledPreamble::Build(
       CI, ContentsBuffer.get(), Bounds, *PreambleDiagsEngine,
diff --git a/clang-tools-extra/clangd/Preamble.h b/clang-tools-extra/clangd/Preamble.h
index 5b9d17840214..8b86d7c1e778 100644
--- a/clang-tools-extra/clangd/Preamble.h
+++ b/clang-tools-extra/clangd/Preamble.h
@@ -24,6 +24,7 @@
 
 #include "CollectMacros.h"
 #include "Compiler.h"
+#include "PCHManager.h"
 #include "Diagnostics.h"
 #include "FS.h"
 #include "Headers.h"
@@ -81,7 +82,7 @@ using PreambleParsedCallback =
 std::shared_ptr<const PreambleData>
 buildPreamble(PathRef FileName, CompilerInvocation CI,
               const ParseInputs &Inputs, bool StoreInMemory,
-              PreambleParsedCallback PreambleCallback);
+              PreambleParsedCallback PreambleCallback, const PCHManager *PCHMgr = nullptr);
 
 /// Returns true if \p Preamble is reusable for \p Inputs. Note that it will
 /// return true when some missing headers are now available.
diff --git a/clang-tools-extra/clangd/TUScheduler.cpp b/clang-tools-extra/clangd/TUScheduler.cpp
index 09c68a3a250b..f9676a9c7f8e 100644
--- a/clang-tools-extra/clangd/TUScheduler.cpp
+++ b/clang-tools-extra/clangd/TUScheduler.cpp
@@ -50,6 +50,7 @@
 #include "Compiler.h"
 #include "Diagnostics.h"
 #include "GlobalCompilationDatabase.h"
+#include "PCHManager.h"
 #include "ParsedAST.h"
 #include "Preamble.h"
 #include "index/CanonicalIncludes.h"
@@ -501,7 +502,7 @@ class ASTWorker {
             TUScheduler::ASTCache &LRUCache,
             TUScheduler::HeaderIncluderCache &HeaderIncluders,
             Semaphore &Barrier, bool RunSync, const TUScheduler::Options &Opts,
-            ParsingCallbacks &Callbacks);
+            ParsingCallbacks &Callbacks, const PCHManager *PCHMgr);
 
 public:
   /// Create a new ASTWorker and return a handle to it.
@@ -514,7 +515,7 @@ public:
          TUScheduler::ASTCache &IdleASTs,
          TUScheduler::HeaderIncluderCache &HeaderIncluders,
          AsyncTaskRunner *Tasks, Semaphore &Barrier,
-         const TUScheduler::Options &Opts, ParsingCallbacks &Callbacks);
+         const TUScheduler::Options &Opts, ParsingCallbacks &Callbacks, const PCHManager *PCHMgr);
   ~ASTWorker();
 
   void update(ParseInputs Inputs, WantDiagnostics, bool ContentChanged);
@@ -614,6 +615,8 @@ private:
   /// Callback to create processing contexts for tasks.
   const std::function<Context(llvm::StringRef)> ContextProvider;
   const GlobalCompilationDatabase &CDB;
+  public:
+  const PCHManager *PCHMgr;
   /// Callback invoked when preamble or main file AST is built.
   ParsingCallbacks &Callbacks;
 
@@ -710,10 +713,10 @@ ASTWorker::create(PathRef FileName, const GlobalCompilationDatabase &CDB,
                   TUScheduler::HeaderIncluderCache &HeaderIncluders,
                   AsyncTaskRunner *Tasks, Semaphore &Barrier,
                   const TUScheduler::Options &Opts,
-                  ParsingCallbacks &Callbacks) {
+                  ParsingCallbacks &Callbacks, const PCHManager *PCHMgr) {
   std::shared_ptr<ASTWorker> Worker(
       new ASTWorker(FileName, CDB, IdleASTs, HeaderIncluders, Barrier,
-                    /*RunSync=*/!Tasks, Opts, Callbacks));
+                    /*RunSync=*/!Tasks, Opts, Callbacks, PCHMgr));
   if (Tasks) {
     Tasks->runAsync("ASTWorker:" + llvm::sys::path::filename(FileName),
                     [Worker]() { Worker->run(); });
@@ -729,10 +732,10 @@ ASTWorker::ASTWorker(PathRef FileName, const GlobalCompilationDatabase &CDB,
                      TUScheduler::HeaderIncluderCache &HeaderIncluders,
                      Semaphore &Barrier, bool RunSync,
                      const TUScheduler::Options &Opts,
-                     ParsingCallbacks &Callbacks)
+                     ParsingCallbacks &Callbacks, const PCHManager *PCHMgr)
     : IdleASTs(LRUCache), HeaderIncluders(HeaderIncluders), RunSync(RunSync),
       UpdateDebounce(Opts.UpdateDebounce), FileName(FileName),
-      ContextProvider(Opts.ContextProvider), CDB(CDB), Callbacks(Callbacks),
+      ContextProvider(Opts.ContextProvider), CDB(CDB), PCHMgr(PCHMgr), Callbacks(Callbacks),
       Barrier(Barrier), Done(false), Status(FileName, Callbacks),
       PreamblePeer(FileName, Callbacks, Opts.StorePreamblesInMemory, RunSync,
                    Status, HeaderIncluders, *this) {
@@ -812,6 +815,19 @@ void ASTWorker::update(ParseInputs Inputs, WantDiagnostics WantDiags,
       vlog("Driver produced command: cc1 {0}", printArgv(CC1Args));
     std::vector<Diag> CompilerInvocationDiags =
         CompilerInvocationDiagConsumer.take();
+    
+    PCHManager::PCHAccess PCH = PCHMgr ? PCHMgr->tryFindPCH(Inputs.CompileCommand) : PCHManager::PCHAccess{};
+    if (PCH)
+    {
+      log("ASTWorker: discovered PCH for {0}. (Version: {1}) Skipping preamble build", FileName, PCH.version());
+      IdleASTs.take(this);
+      RanASTCallback = false;
+      LatestPreamble.emplace();
+      PreambleCV.notify_all();
+      generateDiagnostics(std::move(Invocation), std::move(Inputs), std::move(CompilerInvocationDiags));
+      return;
+    }
+
     if (!Invocation) {
       elog("Could not build CompilerInvocation for file {0}", FileName);
       // Remove the old AST if it's still in cache.
@@ -878,9 +894,10 @@ void ASTWorker::runWithAST(
       // return a compatible preamble as ASTWorker::update blocks.
       llvm::Optional<ParsedAST> NewAST;
       if (Invocation) {
+        PCHManager::PCHAccess PCH = PCHMgr ? PCHMgr->tryFindPCH(FileInputs.CompileCommand) : PCHManager::PCHAccess{};
         NewAST = ParsedAST::build(FileName, FileInputs, std::move(Invocation),
                                   CompilerInvocationDiagConsumer.take(),
-                                  getPossiblyStalePreamble());
+                                  getPossiblyStalePreamble(), &PCH);
         ++ASTBuildCount;
       }
       AST = NewAST ? std::make_unique<ParsedAST>(std::move(*NewAST)) : nullptr;
@@ -932,7 +949,7 @@ void PreambleThread::build(Request Req) {
                                       const CanonicalIncludes &CanonIncludes) {
         Callbacks.onPreambleAST(FileName, Version, Ctx, std::move(PP),
                                 CanonIncludes);
-      });
+      }, ASTPeer.PCHMgr);
   if (LatestBuild && isReliable(LatestBuild->CompileCommand))
     HeaderIncluders.update(FileName, LatestBuild->Includes.allHeaders());
 }
@@ -1039,9 +1056,10 @@ void ASTWorker::generateDiagnostics(
   llvm::Optional<std::unique_ptr<ParsedAST>> AST =
       IdleASTs.take(this, &ASTAccessForDiag);
   if (!AST || !InputsAreLatest) {
+    PCHManager::PCHAccess PCH = PCHMgr ? PCHMgr->tryFindPCH(Inputs.CompileCommand) : PCHManager::PCHAccess{};
     auto RebuildStartTime = DebouncePolicy::clock::now();
     llvm::Optional<ParsedAST> NewAST = ParsedAST::build(
-        FileName, Inputs, std::move(Invocation), CIDiags, *LatestPreamble);
+        FileName, Inputs, std::move(Invocation), CIDiags, *LatestPreamble, &PCH);
     auto RebuildDuration = DebouncePolicy::clock::now() - RebuildStartTime;
     ++ASTBuildCount;
     // Try to record the AST-build time, to inform future update debouncing.
@@ -1446,8 +1464,8 @@ struct TUScheduler::FileData {
 
 TUScheduler::TUScheduler(const GlobalCompilationDatabase &CDB,
                          const Options &Opts,
-                         std::unique_ptr<ParsingCallbacks> Callbacks)
-    : CDB(CDB), Opts(Opts),
+                         std::unique_ptr<ParsingCallbacks> Callbacks, const PCHManager *PCHMgr/* = nullptr*/)
+    : CDB(CDB), Opts(Opts), PCHMgr(PCHMgr),
       Callbacks(Callbacks ? move(Callbacks)
                           : std::make_unique<ParsingCallbacks>()),
       Barrier(Opts.AsyncThreadsCount), QuickRunBarrier(Opts.AsyncThreadsCount),
@@ -1497,7 +1515,7 @@ bool TUScheduler::update(PathRef File, ParseInputs Inputs,
     ASTWorkerHandle Worker =
         ASTWorker::create(File, CDB, *IdleASTs, *HeaderIncluders,
                           WorkerThreads ? WorkerThreads.getPointer() : nullptr,
-                          Barrier, Opts, *Callbacks);
+                          Barrier, Opts, *Callbacks, PCHMgr);
     FD = std::unique_ptr<FileData>(
         new FileData{Inputs.Contents, std::move(Worker)});
     ContentChanged = true;
@@ -1590,10 +1608,11 @@ void TUScheduler::runWithPreamble(llvm::StringRef Name, PathRef File,
     std::shared_ptr<const ASTSignals> Signals;
     std::shared_ptr<const PreambleData> Preamble =
         It->second->Worker->getPossiblyStalePreamble(&Signals);
+    PCHManager::PCHAccess PCH = PCHMgr ? PCHMgr->tryFindPCH(File) : PCHManager::PCHAccess{};
     WithContext WithProvidedContext(Opts.ContextProvider(File));
     Action(InputsAndPreamble{It->second->Contents,
                              It->second->Worker->getCurrentCompileCommand(),
-                             Preamble.get(), Signals.get()});
+                             Preamble.get(), Signals.get(), std::move(PCH)});
     return;
   }
 
@@ -1605,7 +1624,8 @@ void TUScheduler::runWithPreamble(llvm::StringRef Name, PathRef File,
                                                std::string(File)),
                Action = std::move(Action), this]() mutable {
     std::shared_ptr<const PreambleData> Preamble;
-    if (Consistency == PreambleConsistency::Stale) {
+    PCHManager::PCHAccess PCH = PCHMgr ? PCHMgr->tryFindPCH(Command) : PCHManager::PCHAccess{};
+    if ((Consistency == PreambleConsistency::Stale) && !PCH) {
       // Wait until the preamble is built for the first time, if preamble
       // is required. This avoids extra work of processing the preamble
       // headers in parallel multiple times.
@@ -1619,7 +1639,7 @@ void TUScheduler::runWithPreamble(llvm::StringRef Name, PathRef File,
     trace::Span Tracer(Name);
     SPAN_ATTACH(Tracer, "file", File);
     WithContext WithProvidedContext(Opts.ContextProvider(File));
-    Action(InputsAndPreamble{Contents, Command, Preamble.get(), Signals.get()});
+    Action(InputsAndPreamble{Contents, Command, Preamble.get(), Signals.get(), std::move(PCH)});
   };
 
   PreambleTasks->runAsync("task:" + llvm::sys::path::filename(File),
diff --git a/clang-tools-extra/clangd/TUScheduler.h b/clang-tools-extra/clangd/TUScheduler.h
index 02b602173ae6..a9e3e71122ed 100644
--- a/clang-tools-extra/clangd/TUScheduler.h
+++ b/clang-tools-extra/clangd/TUScheduler.h
@@ -13,6 +13,7 @@
 #include "Compiler.h"
 #include "Diagnostics.h"
 #include "GlobalCompilationDatabase.h"
+#include "PCHManager.h"
 #include "index/CanonicalIncludes.h"
 #include "support/Function.h"
 #include "support/MemoryTree.h"
@@ -47,6 +48,7 @@ struct InputsAndPreamble {
   const PreambleData *Preamble;
   // This can be nullptr if no ASTSignals are available.
   const ASTSignals *Signals;
+  PCHManager::PCHAccess PCH;
 };
 
 /// Determines whether diagnostics should be generated for a file snapshot.
@@ -209,7 +211,7 @@ public:
   };
 
   TUScheduler(const GlobalCompilationDatabase &CDB, const Options &Opts,
-              std::unique_ptr<ParsingCallbacks> ASTCallbacks = nullptr);
+              std::unique_ptr<ParsingCallbacks> ASTCallbacks = nullptr, const PCHManager *PCHMgr = nullptr);
   ~TUScheduler();
 
   struct FileStats {
@@ -332,6 +334,7 @@ private:
 
   const GlobalCompilationDatabase &CDB;
   Options Opts;
+  const PCHManager *PCHMgr;
   std::unique_ptr<ParsingCallbacks> Callbacks; // not nullptr
   Semaphore Barrier;
   Semaphore QuickRunBarrier;
diff --git a/clang-tools-extra/clangd/index/Background.cpp b/clang-tools-extra/clangd/index/Background.cpp
index ddfe962d3189..de6bff63d31d 100644
--- a/clang-tools-extra/clangd/index/Background.cpp
+++ b/clang-tools-extra/clangd/index/Background.cpp
@@ -10,6 +10,7 @@
 #include "Compiler.h"
 #include "Config.h"
 #include "Headers.h"
+#include "PCHManager.h"
 #include "ParsedAST.h"
 #include "SourceCode.h"
 #include "Symbol.h"
@@ -94,8 +95,8 @@ bool shardIsStale(const LoadedShard &LS, llvm::vfs::FileSystem *FS) {
 
 BackgroundIndex::BackgroundIndex(
     const ThreadsafeFS &TFS, const GlobalCompilationDatabase &CDB,
-    BackgroundIndexStorage::Factory IndexStorageFactory, Options Opts)
-    : SwapIndex(std::make_unique<MemIndex>()), TFS(TFS), CDB(CDB),
+    BackgroundIndexStorage::Factory IndexStorageFactory, Options Opts, const PCHManager *PCHMgr)
+    : SwapIndex(std::make_unique<MemIndex>()), TFS(TFS), CDB(CDB), PCHMgr(PCHMgr),
       ContextProvider(std::move(Opts.ContextProvider)),
       IndexedSymbols(IndexContents::All),
       Rebuilder(this, &IndexedSymbols, Opts.ThreadPoolSize),
@@ -194,7 +195,8 @@ void BackgroundIndex::update(
     const auto &IGN = IndexIt.getValue();
     auto AbsPath = URI::resolve(IGN.URI, MainFile);
     if (!AbsPath) {
-      elog("Failed to resolve URI: {0}", AbsPath.takeError());
+      if (!IGN.URI.empty())
+        elog("Failed to resolve URI: {0}", AbsPath.takeError());
       continue;
     }
     const auto DigestIt = ShardVersionsSnapshot.find(*AbsPath);
@@ -278,6 +280,13 @@ llvm::Error BackgroundIndex::index(tooling::CompileCommand Cmd) {
   if (!CI)
     return error("Couldn't build compiler invocation");
 
+  auto PCHAccess = PCHMgr ? PCHMgr->findPCH(Inputs.CompileCommand) : PCHManager::PCHAccess();
+  if (PCHAccess)
+  {
+    log("Indexing {0} applying PCH {1}", Inputs.CompileCommand.Filename, PCHAccess.filename());
+    PCHAccess.addPCH(CI.get(), FS);
+  }
+
   auto Clang =
       prepareCompilerInstance(std::move(CI), /*Preamble=*/nullptr,
                               std::move(*Buf), std::move(FS), IgnoreDiags);
diff --git a/clang-tools-extra/clangd/index/Background.h b/clang-tools-extra/clangd/index/Background.h
index 808061b17dff..ad316e2b79f2 100644
--- a/clang-tools-extra/clangd/index/Background.h
+++ b/clang-tools-extra/clangd/index/Background.h
@@ -10,6 +10,7 @@
 #define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_BACKGROUND_H
 
 #include "GlobalCompilationDatabase.h"
+#include "PCHManager.h"
 #include "SourceCode.h"
 #include "index/BackgroundRebuild.h"
 #include "index/FileIndex.h"
@@ -88,6 +89,7 @@ public:
     unsigned Active = 0;    // Tasks being currently processed by a worker.
     unsigned Completed = 0; // Tasks that have been finished.
     unsigned LastIdle = 0;  // Number of completed tasks when last empty.
+    enum class Type {Back, PCH} StatType = Type::Back;
   };
 
   BackgroundQueue(std::function<void(Stats)> OnProgress = nullptr)
@@ -149,7 +151,7 @@ public:
   /// The current Context will be propagated to each worker thread.
   BackgroundIndex(const ThreadsafeFS &, const GlobalCompilationDatabase &CDB,
                   BackgroundIndexStorage::Factory IndexStorageFactory,
-                  Options Opts);
+                  Options Opts, const PCHManager *PCHMgr = nullptr);
   ~BackgroundIndex(); // Blocks while the current task finishes.
 
   // Enqueue translation units for indexing.
@@ -195,6 +197,7 @@ private:
   // configuration
   const ThreadsafeFS &TFS;
   const GlobalCompilationDatabase &CDB;
+  const PCHManager *PCHMgr;
   std::function<Context(PathRef)> ContextProvider;
 
   llvm::Error index(tooling::CompileCommand);
diff --git a/clang-tools-extra/clangd/index/BackgroundIndexLoader.cpp b/clang-tools-extra/clangd/index/BackgroundIndexLoader.cpp
index 5645569c9ae1..6cddc3510fa9 100644
--- a/clang-tools-extra/clangd/index/BackgroundIndexLoader.cpp
+++ b/clang-tools-extra/clangd/index/BackgroundIndexLoader.cpp
@@ -71,7 +71,8 @@ BackgroundIndexLoader::loadShard(PathRef StartSourceFile, PathRef DependentTU) {
   for (const auto &It : *LS.Shard->Sources) {
     auto AbsPath = URI::resolve(It.getKey(), StartSourceFile);
     if (!AbsPath) {
-      elog("Failed to resolve URI: {0}", AbsPath.takeError());
+      if (!It.getKey().empty())
+        elog("Failed to resolve URI: {0}", AbsPath.takeError());
       continue;
     }
     // A shard contains only edges for non main-file sources.
diff --git a/clang-tools-extra/clangd/tool/Check.cpp b/clang-tools-extra/clangd/tool/Check.cpp
index 89487bd8607f..0b9ba6622460 100644
--- a/clang-tools-extra/clangd/tool/Check.cpp
+++ b/clang-tools-extra/clangd/tool/Check.cpp
@@ -176,7 +176,7 @@ public:
 
     log("Building AST...");
     AST = ParsedAST::build(File, Inputs, std::move(Invocation),
-                           /*InvocationDiags=*/std::vector<Diag>{}, Preamble);
+                           /*InvocationDiags=*/std::vector<Diag>{}, Preamble, nullptr);
     if (!AST) {
       elog("Failed to build AST");
       return false;
diff --git a/clang-tools-extra/clangd/tool/ClangdMain.cpp b/clang-tools-extra/clangd/tool/ClangdMain.cpp
index f0aa89b8091f..0c22f855719e 100644
--- a/clang-tools-extra/clangd/tool/ClangdMain.cpp
+++ b/clang-tools-extra/clangd/tool/ClangdMain.cpp
@@ -382,6 +382,13 @@ opt<PCHStorageFlag> PCHStorage{
     init(PCHStorageFlag::Disk),
 };
 
+opt<bool> PCHAlwaysWait{
+    "pch-always-wait",
+    cat(Features),
+    desc("at the start, when processing single file, if there's a PCH specified for it, it will always wait for PCHs to be initialized"),
+    init(true),
+};
+
 opt<bool> Sync{
     "sync",
     cat(Misc),
@@ -808,6 +815,8 @@ clangd accepts flags on the commandline, and in the CLANGD_FLAGS environment var
     Opts.StorePreamblesInMemory = false;
     break;
   }
+  Opts.PCHAlwaysWait = PCHAlwaysWait;
+
   if (!ResourceDir.empty())
     Opts.ResourceDir = ResourceDir;
   Opts.BuildDynamicSymbolIndex = true;
diff --git a/clang/include/clang/Tooling/CompilationDatabase.h b/clang/include/clang/Tooling/CompilationDatabase.h
index 90af15536961..a6d903ab6dae 100644
--- a/clang/include/clang/Tooling/CompilationDatabase.h
+++ b/clang/include/clang/Tooling/CompilationDatabase.h
@@ -42,12 +42,30 @@ namespace tooling {
 
 /// Specifies the working directory and command of a compilation.
 struct CompileCommand {
+
+  /// This is intended to provide an additional info that should help infering
+  /// compile command for files not directly present in compilation database
+  struct Dependency
+  {
+    std::string Filename;
+    std::vector<std::string> RemoveArgs;
+    std::vector<std::string> AddArgs;
+  };
+
   CompileCommand() = default;
   CompileCommand(const Twine &Directory, const Twine &Filename,
                  std::vector<std::string> CommandLine, const Twine &Output)
       : Directory(Directory.str()), Filename(Filename.str()),
         CommandLine(std::move(CommandLine)), Output(Output.str()) {}
 
+  CompileCommand(const Twine &Directory, const Twine &Filename,
+                 std::vector<std::string> CommandLine, const Twine &Output,
+                 std::vector<Dependency> Dependencies)
+      : CompileCommand(Directory, Filename, std::move(CommandLine), Output) { this->Dependencies = std::move(Dependencies); }
+
+  void RemoveDepArgs(const Dependency &d);
+  void ApplyDependency(const Dependency &d);
+
   /// The working directory the command was executed from.
   std::string Directory;
 
@@ -65,6 +83,9 @@ struct CompileCommand {
   /// e.g. "inferred from foo/bar.h".
   std::string Heuristic;
 
+  std::vector<Dependency> Dependencies;
+  int DependencyIndex = -1;
+
   friend bool operator==(const CompileCommand &LHS, const CompileCommand &RHS) {
     return LHS.Directory == RHS.Directory && LHS.Filename == RHS.Filename &&
            LHS.CommandLine == RHS.CommandLine && LHS.Output == RHS.Output &&
@@ -145,6 +166,14 @@ public:
   /// By default, this is implemented in terms of getAllFiles() and
   /// getCompileCommands(). Subclasses may override this for efficiency.
   virtual std::vector<CompileCommand> getAllCompileCommands() const;
+
+  /// Same as getAllFiles but also potentially with additional info
+  virtual std::vector<std::string> getAllFilesWithDeps() const { return getAllFiles(); }
+
+  /// Returns list of all precompiled header files known to the database
+  virtual std::vector<std::string> getAllPCHFiles() const { return {}; }
+  /// Returns list of all commands to generate precompiled headers known to the database
+  virtual std::vector<CompileCommand> getAllPCHCompileCommands() const;
 };
 
 /// A compilation database that returns a single compile command line.
diff --git a/clang/include/clang/Tooling/JSONCompilationDatabase.h b/clang/include/clang/Tooling/JSONCompilationDatabase.h
index 96582457c63d..4a11bbf288d7 100644
--- a/clang/include/clang/Tooling/JSONCompilationDatabase.h
+++ b/clang/include/clang/Tooling/JSONCompilationDatabase.h
@@ -88,10 +88,15 @@ public:
   /// These are the 'file' entries of the JSON objects.
   std::vector<std::string> getAllFiles() const override;
 
+  std::vector<std::string> getAllPCHFiles() const override;
+
   /// Returns all compile commands for all the files in the compilation
   /// database.
   std::vector<CompileCommand> getAllCompileCommands() const override;
 
+  std::vector<CompileCommand> getAllPCHCompileCommands() const override;
+
+  std::vector<std::string> getAllFilesWithDeps() const override;
 private:
   /// Constructs a JSON compilation database on a memory buffer.
   JSONCompilationDatabase(std::unique_ptr<llvm::MemoryBuffer> Database,
@@ -105,6 +110,7 @@ private:
   /// failed.
   bool parse(std::string &ErrorMessage);
 
+  using DepsShared = std::shared_ptr<std::vector<CompileCommand::Dependency>>;
   // Tuple (directory, filename, commandline, output) where 'commandline'
   // points to the corresponding scalar nodes in the YAML stream.
   // If the command line contains a single argument, it is a shell-escaped
@@ -115,20 +121,29 @@ private:
   using CompileCommandRef =
       std::tuple<llvm::yaml::ScalarNode *, llvm::yaml::ScalarNode *,
                  std::vector<llvm::yaml::ScalarNode *>,
-                 llvm::yaml::ScalarNode *>;
+                 llvm::yaml::ScalarNode *, DepsShared>;
 
   /// Converts the given array of CompileCommandRefs to CompileCommands.
   void getCommands(ArrayRef<CompileCommandRef> CommandsRef,
                    std::vector<CompileCommand> &Commands) const;
 
+  bool isPCHCommand(CompileCommandRef const& cmd) const;
+  
+  void inferFromDependent(StringRef FilePath, std::vector<CompileCommand> &Commands) const;
+
   // Maps file paths to the compile command lines for that file.
   llvm::StringMap<std::vector<CompileCommandRef>> IndexByFile;
+  llvm::StringMap<std::vector<CompileCommandRef>> IndexByFileDep;
+  llvm::StringMap<std::vector<CompileCommandRef>> IndexByPCH;
 
   /// All the compile commands in the order that they were provided in the
   /// JSON stream.
   std::vector<CompileCommandRef> AllCommands;
+  std::vector<CompileCommandRef> PCHCommands;
 
   FileMatchTrie MatchTrie;
+  FileMatchTrie MatchTrieDep;
+  FileMatchTrie MatchTriePCH;
 
   std::unique_ptr<llvm::MemoryBuffer> Database;
   JSONCommandLineSyntax Syntax;
diff --git a/clang/lib/Tooling/CompilationDatabase.cpp b/clang/lib/Tooling/CompilationDatabase.cpp
index 1e19e68633d2..e9522d717adb 100644
--- a/clang/lib/Tooling/CompilationDatabase.cpp
+++ b/clang/lib/Tooling/CompilationDatabase.cpp
@@ -58,6 +58,37 @@ using namespace tooling;
 
 LLVM_INSTANTIATE_REGISTRY(CompilationDatabasePluginRegistry)
 
+void CompileCommand::RemoveDepArgs(const Dependency &d)
+{
+  for (const std::string &arg : d.RemoveArgs) {
+    const char *pArg = arg.c_str();
+    int skip = 0;
+    //llvm::errs() << "JSON DB: attempting to remove " << arg << "\n";
+    if (pArg[0] >= '0' && pArg[0] <= '9' && pArg[1] == ':') {
+      skip = pArg[0] - '0';
+      pArg += 2;
+    }
+    //llvm::errs() << "JSON DB: 2 attempting to remove:" << pArg << ";skipping "
+                 //<< skip << "\n";
+    auto it = std::find_if(CommandLine.begin(), CommandLine.end(),
+                           [&](const std::string &xarg) {
+                             return strstr(xarg.c_str(), pArg) == xarg.c_str();
+                           });
+    if (it != CommandLine.end()) {
+      //llvm::errs() << "JSON DB: removing found option " << arg
+                   //<< " and skipping " << skip << "\n";
+      CommandLine.erase(it, it + skip + 1);
+    }
+  }
+}
+void CompileCommand::ApplyDependency(const Dependency &d)
+{
+  RemoveDepArgs(d);
+  if (!d.AddArgs.empty())
+    CommandLine.insert(CommandLine.end(), d.AddArgs.begin(),
+                           d.AddArgs.end());
+}
+
 CompilationDatabase::~CompilationDatabase() = default;
 
 std::unique_ptr<CompilationDatabase>
@@ -138,6 +169,15 @@ std::vector<CompileCommand> CompilationDatabase::getAllCompileCommands() const {
   return Result;
 }
 
+std::vector<CompileCommand> CompilationDatabase::getAllPCHCompileCommands() const {
+  std::vector<CompileCommand> Result;
+  for (const auto &File : getAllPCHFiles()) {
+    auto C = getCompileCommands(File);
+    std::move(C.begin(), C.end(), std::back_inserter(Result));
+  }
+  return Result;
+}
+
 CompilationDatabasePlugin::~CompilationDatabasePlugin() = default;
 
 namespace {
diff --git a/clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp b/clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp
index a825370afcf5..2a2920ef89bf 100644
--- a/clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp
+++ b/clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp
@@ -37,6 +37,14 @@ public:
     return Base->getAllFiles();
   }
 
+  std::vector<std::string> getAllPCHFiles() const override {
+    return Base->getAllPCHFiles();
+  }
+
+  std::vector<std::string> getAllFilesWithDeps() const override {
+    return Base->getAllFilesWithDeps();
+  }
+
   std::vector<CompileCommand>
   getCompileCommands(StringRef FilePath) const override {
     return expand(Base->getCompileCommands(FilePath));
@@ -46,6 +54,10 @@ public:
     return expand(Base->getAllCompileCommands());
   }
 
+  std::vector<CompileCommand> getAllPCHCompileCommands() const override {
+    return expand(Base->getAllPCHCompileCommands());
+  }
+
 private:
   std::vector<CompileCommand> expand(std::vector<CompileCommand> Cmds) const {
     for (auto &Cmd : Cmds) {
diff --git a/clang/lib/Tooling/GuessTargetAndModeCompilationDatabase.cpp b/clang/lib/Tooling/GuessTargetAndModeCompilationDatabase.cpp
index b6c1c0952aca..bc4fe6fe9cde 100644
--- a/clang/lib/Tooling/GuessTargetAndModeCompilationDatabase.cpp
+++ b/clang/lib/Tooling/GuessTargetAndModeCompilationDatabase.cpp
@@ -29,6 +29,14 @@ public:
     return addTargetAndMode(Base->getAllCompileCommands());
   }
 
+  std::vector<std::string> getAllPCHFiles() const override {
+    return Base->getAllPCHFiles();
+  }
+
+  std::vector<CompileCommand> getAllPCHCompileCommands() const override {
+    return addTargetAndMode(Base->getAllPCHCompileCommands());
+  }
+
   std::vector<CompileCommand>
   getCompileCommands(StringRef FilePath) const override {
     return addTargetAndMode(Base->getCompileCommands(FilePath));
diff --git a/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp b/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
index 3b65504b98ea..f0293fc7a40a 100644
--- a/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
+++ b/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
@@ -431,38 +431,68 @@ private:
       int Points;
       size_t PrefixLength;
     };
-    // Choose the best candidate by (preferred, points, prefix length, alpha).
-    ScoredCandidate Best = {size_t(-1), false, 0, 0};
-    for (const auto &Candidate : Candidates) {
-      ScoredCandidate S;
-      S.Index = Candidate.first;
-      S.Preferred = PreferredLanguage == types::TY_INVALID ||
-                    PreferredLanguage == Types[S.Index];
-      S.Points = Candidate.second;
+    StringRef extOrig = llvm::sys::path::extension(Filename);
+    auto BetterThan = [&](ScoredCandidate &S, ScoredCandidate const &Best){
       if (!S.Preferred && Best.Preferred)
-        continue;
+        return false;
       if (S.Preferred == Best.Preferred) {
         if (S.Points < Best.Points)
-          continue;
+          return false;
         if (S.Points == Best.Points) {
           S.PrefixLength = matchingPrefix(Filename, Paths[S.Index].first);
           if (S.PrefixLength < Best.PrefixLength)
-            continue;
+            return false;
           // hidden heuristics should at least be deterministic!
           if (S.PrefixLength == Best.PrefixLength)
             if (S.Index > Best.Index)
-              continue;
+              return false;
+        }
+      }
+
+      return true;
+    };
+    // Choose the best candidate by (preferred, points, prefix length, alpha).
+    ScoredCandidate Best = {size_t(-1), false, 0, 0};
+    ScoredCandidate BestExt = {size_t(-1), false, 0, 0};
+
+    for (const auto &Candidate : Candidates) {
+      ScoredCandidate S;
+      S.Index = Candidate.first;
+      S.Preferred = PreferredLanguage == types::TY_INVALID ||
+                    PreferredLanguage == Types[S.Index];
+      S.Points = Candidate.second;
+      StringRef sExt = llvm::sys::path::extension(OriginalPaths[S.Index]);
+      if (BetterThan(S, Best))
+      {
+        // PrefixLength was only set above if actually needed for a tiebreak.
+        // But it definitely needs to be set to break ties in the future.
+        S.PrefixLength = matchingPrefix(Filename, Paths[S.Index].first);
+        Best = S;
+        if (sExt == extOrig)
+        {
+          BestExt = S;
+        }
+      }
+      if (sExt == extOrig)
+      {
+        if (BetterThan(S, BestExt)) {
+          // PrefixLength was only set above if actually needed for a tiebreak.
+          // But it definitely needs to be set to break ties in the future.
+          S.PrefixLength = matchingPrefix(Filename, Paths[S.Index].first);
+          BestExt = S;
         }
       }
-      // PrefixLength was only set above if actually needed for a tiebreak.
-      // But it definitely needs to be set to break ties in the future.
-      S.PrefixLength = matchingPrefix(Filename, Paths[S.Index].first);
-      Best = S;
     }
+
     // Edge case: no candidate got any points.
     // We ignore PreferredLanguage at this point (not ideal).
     if (Best.Index == size_t(-1))
       return {longestMatch(Filename, Paths).second, 0};
+
+    //prefer with matched extension
+    if (BestExt.Index != size_t(-1))
+      return {BestExt.Index, BestExt.Points};
+
     return {Best.Index, Best.Points};
   }
 
@@ -513,13 +543,25 @@ private:
 class InterpolatingCompilationDatabase : public CompilationDatabase {
 public:
   InterpolatingCompilationDatabase(std::unique_ptr<CompilationDatabase> Inner)
-      : Inner(std::move(Inner)), Index(this->Inner->getAllFiles()) {}
+      : Inner(std::move(Inner)), Index(this->Inner->getAllFilesWithDeps()) {}
 
   std::vector<CompileCommand>
   getCompileCommands(StringRef Filename) const override {
     auto Known = Inner->getCompileCommands(Filename);
     if (Index.empty() || !Known.empty())
+    {
+      for(CompileCommand &cc : Known)
+      {
+        if (cc.DependencyIndex >= 0)
+        {
+          cc.ApplyDependency(cc.Dependencies[cc.DependencyIndex]);
+          CompileCommand trans = TransferableCommand(cc).transferTo(Filename);
+          cc = trans;
+          llvm::errs() << "Found dependency to apply for " << Filename << ". (Dep: " << cc.Dependencies[cc.DependencyIndex].Filename << ") ";
+        }
+      }
       return Known;
+    }
     bool TypeCertain;
     auto Lang = guessType(Filename, &TypeCertain);
     if (!TypeCertain)
@@ -528,17 +570,38 @@ public:
         Inner->getCompileCommands(Index.chooseProxy(Filename, foldType(Lang)));
     if (ProxyCommands.empty())
       return {};
-    return {transferCompileCommand(std::move(ProxyCommands.front()), Filename)};
+
+    CompileCommand &proxy = ProxyCommands[0];
+    if (proxy.DependencyIndex >= 0)
+    {
+      proxy.ApplyDependency(proxy.Dependencies[proxy.DependencyIndex]);
+      llvm::errs() << "Found dependency to apply for proxy " << Filename << ". (Dep: " << proxy.Dependencies[proxy.DependencyIndex].Filename << ") ";
+    }
+    CompileCommand trans = TransferableCommand(proxy).transferTo(Filename);
+
+    return {trans};
   }
 
   std::vector<std::string> getAllFiles() const override {
     return Inner->getAllFiles();
   }
 
+  std::vector<std::string> getAllFilesWithDeps() const override {
+    return Inner->getAllFilesWithDeps();
+  }
+
   std::vector<CompileCommand> getAllCompileCommands() const override {
     return Inner->getAllCompileCommands();
   }
 
+  std::vector<std::string> getAllPCHFiles() const override {
+    return Inner->getAllPCHFiles();
+  }
+
+  std::vector<CompileCommand> getAllPCHCompileCommands() const override {
+    return Inner->getAllPCHCompileCommands();
+  }
+
 private:
   std::unique_ptr<CompilationDatabase> Inner;
   FileIndex Index;
diff --git a/clang/lib/Tooling/JSONCompilationDatabase.cpp b/clang/lib/Tooling/JSONCompilationDatabase.cpp
index 97ba7e411fbb..a75f78e4610f 100644
--- a/clang/lib/Tooling/JSONCompilationDatabase.cpp
+++ b/clang/lib/Tooling/JSONCompilationDatabase.cpp
@@ -28,6 +28,7 @@
 #include "llvm/Support/Host.h"
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/Path.h"
+#include "llvm/Support/Signals.h"
 #include "llvm/Support/StringSaver.h"
 #include "llvm/Support/VirtualFileSystem.h"
 #include "llvm/Support/YAMLParser.h"
@@ -230,27 +231,98 @@ JSONCompilationDatabase::getCompileCommands(StringRef FilePath) const {
   SmallString<128> NativeFilePath;
   llvm::sys::path::native(FilePath, NativeFilePath);
 
-  std::string Error;
-  llvm::raw_string_ostream ES(Error);
-  StringRef Match = MatchTrie.findEquivalent(NativeFilePath, ES);
-  if (Match.empty())
-    return {};
-  const auto CommandsRefI = IndexByFile.find(Match);
-  if (CommandsRefI == IndexByFile.end())
-    return {};
+  auto checkIndex = [](FileMatchTrie const& match, llvm::StringMap<std::vector<CompileCommandRef>> const& idx, const SmallString<128>& NativeFilePath)
+  {
+    std::string Error;
+    llvm::raw_string_ostream ES(Error);
+    StringRef Match = match.findEquivalent(NativeFilePath, ES);
+    if (Match.empty())
+      return idx.end();
+    return idx.find(Match);
+  };
+
   std::vector<CompileCommand> Commands;
-  getCommands(CommandsRefI->getValue(), Commands);
+  auto tryGetCommands = [&](decltype(IndexByFile)::const_iterator it, bool withDeps)
+  {
+    bool atLeastOneExactMatch = false;
+    getCommands(it->getValue(), Commands);
+    for (CompileCommand &cc : Commands) {
+      StringRef ccfn = cc.Filename;
+      if (ccfn.endswith(FilePath)) 
+        atLeastOneExactMatch = true;
+      else if (withDeps) {
+        for (size_t i = 0; i < cc.Dependencies.size(); ++i) {
+          CompileCommand::Dependency const &d = cc.Dependencies[i];
+          StringRef fn = d.Filename;
+          if (fn.endswith(FilePath)) {
+            cc.DependencyIndex = (int)i;
+            break;
+          }
+        }
+      }
+    }
+    return atLeastOneExactMatch;
+  };
+
+  bool checkDeps = true;
+  {
+    const auto mainIdx = checkIndex(MatchTrie, IndexByFile, NativeFilePath);
+    if (mainIdx != IndexByFile.end())
+      checkDeps = !tryGetCommands(mainIdx, false);
+  }
+
+  if (!IndexByFileDep.empty() && checkDeps)
+  {
+    const auto depIdx = checkIndex(MatchTrieDep, IndexByFileDep, NativeFilePath);
+    if (depIdx != IndexByFileDep.end())
+      checkDeps = !tryGetCommands(depIdx, true);
+  }
+
+  if (!IndexByPCH.empty() && checkDeps)
+  {
+    const auto depIdx = checkIndex(MatchTriePCH, IndexByPCH, NativeFilePath);
+    if (depIdx != IndexByPCH.end())
+      checkDeps = !tryGetCommands(depIdx, true);
+  }
   return Commands;
 }
 
 std::vector<std::string>
 JSONCompilationDatabase::getAllFiles() const {
   std::vector<std::string> Result;
+  Result.reserve(IndexByFile.size());
+  for (const auto &CommandRef : IndexByFile)
+    Result.push_back(CommandRef.first().str());
+  return Result;
+}
+
+std::vector<std::string> JSONCompilationDatabase::getAllPCHFiles() const
+{
+  std::vector<std::string> Result;
+  Result.reserve(IndexByPCH.size());
+  for (const auto &CommandRef : IndexByPCH)
+    Result.emplace_back(CommandRef.first().str());
+  return Result;
+}
+
+std::vector<std::string> JSONCompilationDatabase::getAllFilesWithDeps() const
+{
+  std::vector<std::string> Result;
+  Result.reserve(IndexByFile.size() + IndexByFileDep.size());
   for (const auto &CommandRef : IndexByFile)
     Result.push_back(CommandRef.first().str());
+  for (const auto &CommandRef : IndexByFileDep)
+    Result.push_back(CommandRef.first().str());
   return Result;
 }
 
+std::vector<CompileCommand> JSONCompilationDatabase::getAllPCHCompileCommands() const
+{
+  std::vector<CompileCommand> Commands;
+  getCommands(PCHCommands, Commands);
+  return Commands;
+}
+
 std::vector<CompileCommand>
 JSONCompilationDatabase::getAllCompileCommands() const {
   std::vector<CompileCommand> Commands;
@@ -313,6 +385,65 @@ nodeToCommandLine(JSONCommandLineSyntax Syntax,
   return Arguments;
 }
 
+static bool ParseCompileCommandDependency(llvm::yaml::MappingNode *pNode, CompileCommand::Dependency &d)
+{
+  for (auto &depKeyValue : *pNode) {
+    auto *KeyString = dyn_cast<llvm::yaml::ScalarNode>(depKeyValue.getKey());
+    if (!KeyString) {
+      return false;
+    }
+    SmallString<10> KeyStorage;
+    StringRef KeyValue = KeyString->getValue(KeyStorage);
+    llvm::yaml::Node *Value = depKeyValue.getValue();
+    if (!Value) {
+      return false;
+    }
+    auto *ValueString = dyn_cast<llvm::yaml::ScalarNode>(Value);
+    auto *SequenceString = dyn_cast<llvm::yaml::SequenceNode>(Value);
+    if (KeyValue == "file") {
+      if (!ValueString) {
+        return false;
+      }
+      SmallString<10> FileStorage;
+      StringRef FilenameValue = ValueString->getValue(FileStorage);
+      d.Filename = FilenameValue.str();
+    } else if (KeyValue == "add" || KeyValue == "remove") {
+      if (!SequenceString) {
+        return false;
+      }
+      std::vector<std::string> &v =
+          KeyValue == "add" ? d.AddArgs : d.RemoveArgs;
+      for (auto &Argument : *SequenceString) {
+        auto *Scalar = dyn_cast<llvm::yaml::ScalarNode>(&Argument);
+        if (!Scalar) {
+          return false;
+        }
+        SmallString<10> ArgStorage;
+        StringRef ArgValue = Scalar->getValue(ArgStorage);
+        v.push_back(ArgValue.str());
+      }
+    }
+  }
+  return true;
+}
+
+static bool ParseCompileCommandDependencies(llvm::yaml::SequenceNode *pDeps, std::vector<CompileCommand::Dependency> &deps)
+{
+  bool res = true;
+  for (auto &depNode : *pDeps) {
+    auto *Dep = dyn_cast<llvm::yaml::MappingNode>(&depNode);
+    if (!Dep) {
+      return false;
+    }
+    CompileCommand::Dependency d;
+    if (ParseCompileCommandDependency(Dep, d))
+      deps.push_back(std::move(d));
+    else
+      res = false;
+  }
+  return res;
+}
+
 void JSONCompilationDatabase::getCommands(
     ArrayRef<CompileCommandRef> CommandsRef,
     std::vector<CompileCommand> &Commands) const {
@@ -320,15 +451,47 @@ void JSONCompilationDatabase::getCommands(
     SmallString<8> DirectoryStorage;
     SmallString<32> FilenameStorage;
     SmallString<32> OutputStorage;
-    auto Output = std::get<3>(CommandRef);
+    auto *Output = std::get<3>(CommandRef);
+    std::vector<CompileCommand::Dependency> deps;
+    auto depsShared = std::get<4>(CommandRef);
+    if (depsShared.get()) deps = *depsShared;
+
     Commands.emplace_back(
         std::get<0>(CommandRef)->getValue(DirectoryStorage),
         std::get<1>(CommandRef)->getValue(FilenameStorage),
         nodeToCommandLine(Syntax, std::get<2>(CommandRef)),
-        Output ? Output->getValue(OutputStorage) : "");
+        Output ? Output->getValue(OutputStorage) : "",
+        std::move(deps));
   }
 }
 
+bool JSONCompilationDatabase::isPCHCommand(CompileCommandRef const& cmd) const
+{
+  bool res = false;
+  auto const& commands = std::get<2>(cmd);
+  if (commands.size() == 1)
+  {
+    StringRef rawVal = commands[0]->getRawValue();
+    size_t p = 0;
+    while((p = rawVal.find("c++-header", p)) != StringRef::npos)
+    {
+      size_t cppheader = p;
+      if ((p = rawVal.rfind('x', p)) != StringRef::npos && (p > 0))
+      {
+        if ((rawVal[p - 1] == '-') && (rawVal.find_first_not_of(' ', p + 1) == cppheader))
+        {
+          res = true;
+          break;
+        }
+      }
+    }
+  }else
+  {
+    //TODO: analyze arguments
+  }
+  return res;
+}
+
 bool JSONCompilationDatabase::parse(std::string &ErrorMessage) {
   llvm::yaml::document_iterator I = YAMLStream.begin();
   if (I == YAMLStream.end()) {
@@ -355,6 +518,8 @@ bool JSONCompilationDatabase::parse(std::string &ErrorMessage) {
     llvm::Optional<std::vector<llvm::yaml::ScalarNode *>> Command;
     llvm::yaml::ScalarNode *File = nullptr;
     llvm::yaml::ScalarNode *Output = nullptr;
+    DepsShared Dependencies;
+
     for (auto& NextKeyValue : *Object) {
       auto *KeyString = dyn_cast<llvm::yaml::ScalarNode>(NextKeyValue.getKey());
       if (!KeyString) {
@@ -384,6 +549,14 @@ bool JSONCompilationDatabase::parse(std::string &ErrorMessage) {
           }
           Command->push_back(Scalar);
         }
+      } else if (KeyValue == "dependencies") {
+        if (!SequenceString) {
+          ErrorMessage = "Expected sequence as value.";
+          return false;
+        }
+        Dependencies.reset(new std::vector<CompileCommand::Dependency>());
+        if (!ParseCompileCommandDependencies(SequenceString, *Dependencies))
+          ErrorMessage = "Wrong deps";
       } else {
         if (!ValueString) {
           ErrorMessage = "Expected string as value.";
@@ -419,21 +592,53 @@ bool JSONCompilationDatabase::parse(std::string &ErrorMessage) {
     }
     SmallString<8> FileStorage;
     StringRef FileName = File->getValue(FileStorage);
-    SmallString<128> NativeFilePath;
-    if (llvm::sys::path::is_relative(FileName)) {
-      SmallString<8> DirectoryStorage;
-      SmallString<128> AbsolutePath(
-          Directory->getValue(DirectoryStorage));
-      llvm::sys::path::append(AbsolutePath, FileName);
-      llvm::sys::path::remove_dots(AbsolutePath, /*remove_dot_dot=*/ true);
-      llvm::sys::path::native(AbsolutePath, NativeFilePath);
-    } else {
-      llvm::sys::path::native(FileName, NativeFilePath);
+    auto FileNameToNative = [&Directory](StringRef FileName)->SmallString<128>
+    {
+      SmallString<128> NativeFilePath;
+      if (llvm::sys::path::is_relative(FileName)) {
+        SmallString<8> DirectoryStorage;
+        SmallString<128> AbsolutePath(
+            Directory->getValue(DirectoryStorage));
+        llvm::sys::path::append(AbsolutePath, FileName);
+        llvm::sys::path::remove_dots(AbsolutePath, /*remove_dot_dot=*/ true);
+        llvm::sys::path::native(AbsolutePath, NativeFilePath);
+      } else {
+        llvm::sys::path::native(FileName, NativeFilePath);
+      }
+      return NativeFilePath;
+    };
+    SmallString<128> NativeFilePath = FileNameToNative(FileName);
+
+    if (!ErrorMessage.empty())
+    {
+      llvm::errs() << "Error with deps for file " << NativeFilePath << "\n";
+    }
+
+    auto Cmd = CompileCommandRef(Directory, File, *Command, Output, Dependencies);
+    if (isPCHCommand(Cmd))
+    {
+      IndexByPCH[NativeFilePath].push_back(Cmd);
+      MatchTriePCH.insert(NativeFilePath);
+      PCHCommands.push_back(Cmd);
+    }else
+    {
+      IndexByFile[NativeFilePath].push_back(Cmd);
+      MatchTrie.insert(NativeFilePath);
+      AllCommands.push_back(Cmd);
     }
-    auto Cmd = CompileCommandRef(Directory, File, *Command, Output);
-    IndexByFile[NativeFilePath].push_back(Cmd);
-    AllCommands.push_back(Cmd);
-    MatchTrie.insert(NativeFilePath);
+
+    if (Dependencies.get())
+    {
+      for (CompileCommand::Dependency const &d : *Dependencies) {
+        SmallString<128> NativeFilePathDep = FileNameToNative(d.Filename);
+        IndexByFileDep[NativeFilePathDep].push_back(Cmd);
+        MatchTrieDep.insert(NativeFilePathDep);
+      }
+    }
+  }
+  if (!PCHCommands.empty())
+  {
+      llvm::errs() << "Found " << PCHCommands.size() << " PCH commands\n";
   }
   return true;
 }
