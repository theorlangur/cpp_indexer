diff --git a/clang/include/clang/Tooling/CompilationDatabase.h b/clang/include/clang/Tooling/CompilationDatabase.h
index 90af15536961..768cc5446b2b 100644
--- a/clang/include/clang/Tooling/CompilationDatabase.h
+++ b/clang/include/clang/Tooling/CompilationDatabase.h
@@ -42,12 +42,29 @@ namespace tooling {
 
 /// Specifies the working directory and command of a compilation.
 struct CompileCommand {
+
+  /// This is intended to provide an additional info that should help infering
+  /// compile command for files not directly present in compilation database
+  struct Dependency
+  {
+    std::string Filename;
+    std::vector<std::string> RemoveArgs;
+    std::vector<std::string> AddArgs;
+  };
+
   CompileCommand() = default;
   CompileCommand(const Twine &Directory, const Twine &Filename,
                  std::vector<std::string> CommandLine, const Twine &Output)
       : Directory(Directory.str()), Filename(Filename.str()),
         CommandLine(std::move(CommandLine)), Output(Output.str()) {}
 
+  CompileCommand(const Twine &Directory, const Twine &Filename,
+                 std::vector<std::string> CommandLine, const Twine &Output,
+                 std::vector<Dependency> Dependencies)
+      : CompileCommand(Directory, Filename, std::move(CommandLine), Output) { this->Dependencies = std::move(Dependencies); }
+
+  void ApplyDependency(const Dependency &d);
+
   /// The working directory the command was executed from.
   std::string Directory;
 
@@ -65,6 +82,9 @@ struct CompileCommand {
   /// e.g. "inferred from foo/bar.h".
   std::string Heuristic;
 
+  std::vector<Dependency> Dependencies;
+  int DependencyIndex = -1;
+
   friend bool operator==(const CompileCommand &LHS, const CompileCommand &RHS) {
     return LHS.Directory == RHS.Directory && LHS.Filename == RHS.Filename &&
            LHS.CommandLine == RHS.CommandLine && LHS.Output == RHS.Output &&
@@ -145,6 +165,9 @@ public:
   /// By default, this is implemented in terms of getAllFiles() and
   /// getCompileCommands(). Subclasses may override this for efficiency.
   virtual std::vector<CompileCommand> getAllCompileCommands() const;
+
+  /// Same as getAllFiles but also potentially with additional info
+  virtual std::vector<std::string> getAllFilesWithDeps() const { return getAllFiles(); }
 };
 
 /// A compilation database that returns a single compile command line.
diff --git a/clang/include/clang/Tooling/JSONCompilationDatabase.h b/clang/include/clang/Tooling/JSONCompilationDatabase.h
index 96582457c63d..438788298ba0 100644
--- a/clang/include/clang/Tooling/JSONCompilationDatabase.h
+++ b/clang/include/clang/Tooling/JSONCompilationDatabase.h
@@ -92,6 +92,7 @@ public:
   /// database.
   std::vector<CompileCommand> getAllCompileCommands() const override;
 
+  virtual std::vector<std::string> getAllFilesWithDeps() const override;
 private:
   /// Constructs a JSON compilation database on a memory buffer.
   JSONCompilationDatabase(std::unique_ptr<llvm::MemoryBuffer> Database,
@@ -105,6 +106,7 @@ private:
   /// failed.
   bool parse(std::string &ErrorMessage);
 
+  using DepsShared = std::shared_ptr<std::vector<CompileCommand::Dependency>>;
   // Tuple (directory, filename, commandline, output) where 'commandline'
   // points to the corresponding scalar nodes in the YAML stream.
   // If the command line contains a single argument, it is a shell-escaped
@@ -115,20 +117,24 @@ private:
   using CompileCommandRef =
       std::tuple<llvm::yaml::ScalarNode *, llvm::yaml::ScalarNode *,
                  std::vector<llvm::yaml::ScalarNode *>,
-                 llvm::yaml::ScalarNode *>;
+                 llvm::yaml::ScalarNode *, DepsShared>;
 
   /// Converts the given array of CompileCommandRefs to CompileCommands.
   void getCommands(ArrayRef<CompileCommandRef> CommandsRef,
                    std::vector<CompileCommand> &Commands) const;
+  
+  void inferFromDependent(StringRef FilePath, std::vector<CompileCommand> &Commands) const;
 
   // Maps file paths to the compile command lines for that file.
   llvm::StringMap<std::vector<CompileCommandRef>> IndexByFile;
+  llvm::StringMap<std::vector<CompileCommandRef>> IndexByFileDep;
 
   /// All the compile commands in the order that they were provided in the
   /// JSON stream.
   std::vector<CompileCommandRef> AllCommands;
 
   FileMatchTrie MatchTrie;
+  FileMatchTrie MatchTrieDep;
 
   std::unique_ptr<llvm::MemoryBuffer> Database;
   JSONCommandLineSyntax Syntax;
diff --git a/clang/lib/Tooling/CompilationDatabase.cpp b/clang/lib/Tooling/CompilationDatabase.cpp
index 1e19e68633d2..a9c40f1670a9 100644
--- a/clang/lib/Tooling/CompilationDatabase.cpp
+++ b/clang/lib/Tooling/CompilationDatabase.cpp
@@ -58,6 +58,33 @@ using namespace tooling;
 
 LLVM_INSTANTIATE_REGISTRY(CompilationDatabasePluginRegistry)
 
+void CompileCommand::ApplyDependency(const Dependency &d)
+{
+  for (const std::string &arg : d.RemoveArgs) {
+    const char *pArg = arg.c_str();
+    int skip = 0;
+    //llvm::errs() << "JSON DB: attempting to remove " << arg << "\n";
+    if (pArg[0] >= '0' && pArg[0] <= '9' && pArg[1] == ':') {
+      skip = pArg[0] - '0';
+      pArg += 2;
+    }
+    //llvm::errs() << "JSON DB: 2 attempting to remove:" << pArg << ";skipping "
+                 //<< skip << "\n";
+    auto it = std::find_if(CommandLine.begin(), CommandLine.end(),
+                           [&](const std::string &xarg) {
+                             return strstr(xarg.c_str(), pArg) == xarg.c_str();
+                           });
+    if (it != CommandLine.end()) {
+      //llvm::errs() << "JSON DB: removing found option " << arg
+                   //<< " and skipping " << skip << "\n";
+      CommandLine.erase(it, it + skip + 1);
+    }
+  }
+  if (!d.AddArgs.empty())
+    CommandLine.insert(CommandLine.end(), d.AddArgs.begin(),
+                           d.AddArgs.end());
+}
+
 CompilationDatabase::~CompilationDatabase() = default;
 
 std::unique_ptr<CompilationDatabase>
diff --git a/clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp b/clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp
index f1ab2aed54c0..a5fabc6ab7a1 100644
--- a/clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp
+++ b/clang/lib/Tooling/ExpandResponseFilesCompilationDatabase.cpp
@@ -37,6 +37,10 @@ public:
     return Base->getAllFiles();
   }
 
+  std::vector<std::string> getAllFilesWithDeps() const override {
+    return Base->getAllFilesWithDeps();
+  }
+
   std::vector<CompileCommand>
   getCompileCommands(StringRef FilePath) const override {
     return expand(Base->getCompileCommands(FilePath));
diff --git a/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp b/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
index 3b65504b98ea..d7148a77440b 100644
--- a/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
+++ b/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp
@@ -431,38 +431,63 @@ private:
       int Points;
       size_t PrefixLength;
     };
-    // Choose the best candidate by (preferred, points, prefix length, alpha).
-    ScoredCandidate Best = {size_t(-1), false, 0, 0};
-    for (const auto &Candidate : Candidates) {
-      ScoredCandidate S;
-      S.Index = Candidate.first;
-      S.Preferred = PreferredLanguage == types::TY_INVALID ||
-                    PreferredLanguage == Types[S.Index];
-      S.Points = Candidate.second;
+    StringRef extOrig = llvm::sys::path::extension(Filename);
+    auto BetterThan = [&](ScoredCandidate &S, ScoredCandidate const &Best){
       if (!S.Preferred && Best.Preferred)
-        continue;
+        return false;
       if (S.Preferred == Best.Preferred) {
         if (S.Points < Best.Points)
-          continue;
+          return false;
         if (S.Points == Best.Points) {
           S.PrefixLength = matchingPrefix(Filename, Paths[S.Index].first);
           if (S.PrefixLength < Best.PrefixLength)
-            continue;
+            return false;
           // hidden heuristics should at least be deterministic!
           if (S.PrefixLength == Best.PrefixLength)
             if (S.Index > Best.Index)
-              continue;
+              return false;
+        }
+      }
+
+      return true;
+    };
+    // Choose the best candidate by (preferred, points, prefix length, alpha).
+    ScoredCandidate Best = {size_t(-1), false, 0, 0};
+    ScoredCandidate BestExt = {size_t(-1), false, 0, 0};
+
+    for (const auto &Candidate : Candidates) {
+      ScoredCandidate S;
+      S.Index = Candidate.first;
+      S.Preferred = PreferredLanguage == types::TY_INVALID ||
+                    PreferredLanguage == Types[S.Index];
+      S.Points = Candidate.second;
+      if (BetterThan(S, Best))
+      {
+        // PrefixLength was only set above if actually needed for a tiebreak.
+        // But it definitely needs to be set to break ties in the future.
+        S.PrefixLength = matchingPrefix(Filename, Paths[S.Index].first);
+        Best = S;
+      }
+      StringRef sExt = llvm::sys::path::extension(Paths[S.Index].first);
+      if (sExt == extOrig)
+      {
+        if (BetterThan(S, BestExt)) {
+          // PrefixLength was only set above if actually needed for a tiebreak.
+          // But it definitely needs to be set to break ties in the future.
+          S.PrefixLength = matchingPrefix(Filename, Paths[S.Index].first);
+          BestExt = S;
         }
       }
-      // PrefixLength was only set above if actually needed for a tiebreak.
-      // But it definitely needs to be set to break ties in the future.
-      S.PrefixLength = matchingPrefix(Filename, Paths[S.Index].first);
-      Best = S;
     }
     // Edge case: no candidate got any points.
     // We ignore PreferredLanguage at this point (not ideal).
     if (Best.Index == size_t(-1))
       return {longestMatch(Filename, Paths).second, 0};
+
+    //prefer with matched extension
+    if (BestExt.Index != size_t(-1))
+      return {BestExt.Index, BestExt.Points};
+
     return {Best.Index, Best.Points};
   }
 
@@ -513,13 +538,25 @@ private:
 class InterpolatingCompilationDatabase : public CompilationDatabase {
 public:
   InterpolatingCompilationDatabase(std::unique_ptr<CompilationDatabase> Inner)
-      : Inner(std::move(Inner)), Index(this->Inner->getAllFiles()) {}
+      : Inner(std::move(Inner)), Index(this->Inner->getAllFilesWithDeps()) {}
 
   std::vector<CompileCommand>
   getCompileCommands(StringRef Filename) const override {
     auto Known = Inner->getCompileCommands(Filename);
     if (Index.empty() || !Known.empty())
+    {
+      for(CompileCommand &cc : Known)
+      {
+        if (cc.DependencyIndex >= 0)
+        {
+          CompileCommand trans = TransferableCommand(cc).transferTo(Filename);
+          trans.ApplyDependency(cc.Dependencies[cc.DependencyIndex]);
+          cc = trans;
+          llvm::errs() << "Found dependency to apply for " << Filename << ". (Dep: " << cc.Dependencies[cc.DependencyIndex].Filename << ") ";
+        }
+      }
       return Known;
+    }
     bool TypeCertain;
     auto Lang = guessType(Filename, &TypeCertain);
     if (!TypeCertain)
@@ -528,13 +565,26 @@ public:
         Inner->getCompileCommands(Index.chooseProxy(Filename, foldType(Lang)));
     if (ProxyCommands.empty())
       return {};
-    return {transferCompileCommand(std::move(ProxyCommands.front()), Filename)};
+
+    CompileCommand &proxy = ProxyCommands[0];
+    CompileCommand trans = TransferableCommand(proxy).transferTo(Filename);
+    if (proxy.DependencyIndex >= 0)
+    {
+      trans.ApplyDependency(proxy.Dependencies[proxy.DependencyIndex]);
+      llvm::errs() << "Found dependency to apply for proxy " << Filename << ". (Dep: " << proxy.Dependencies[proxy.DependencyIndex].Filename << ") ";
+    }
+
+    return {trans};
   }
 
   std::vector<std::string> getAllFiles() const override {
     return Inner->getAllFiles();
   }
 
+  std::vector<std::string> getAllFilesWithDeps() const override {
+    return Inner->getAllFilesWithDeps();
+  }
+
   std::vector<CompileCommand> getAllCompileCommands() const override {
     return Inner->getAllCompileCommands();
   }
diff --git a/clang/lib/Tooling/JSONCompilationDatabase.cpp b/clang/lib/Tooling/JSONCompilationDatabase.cpp
index 97ba7e411fbb..14172b8d8903 100644
--- a/clang/lib/Tooling/JSONCompilationDatabase.cpp
+++ b/clang/lib/Tooling/JSONCompilationDatabase.cpp
@@ -28,6 +28,7 @@
 #include "llvm/Support/Host.h"
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/Path.h"
+#include "llvm/Support/Signals.h"
 #include "llvm/Support/StringSaver.h"
 #include "llvm/Support/VirtualFileSystem.h"
 #include "llvm/Support/YAMLParser.h"
@@ -230,24 +231,73 @@ JSONCompilationDatabase::getCompileCommands(StringRef FilePath) const {
   SmallString<128> NativeFilePath;
   llvm::sys::path::native(FilePath, NativeFilePath);
 
-  std::string Error;
-  llvm::raw_string_ostream ES(Error);
-  StringRef Match = MatchTrie.findEquivalent(NativeFilePath, ES);
-  if (Match.empty())
-    return {};
-  const auto CommandsRefI = IndexByFile.find(Match);
-  if (CommandsRefI == IndexByFile.end())
-    return {};
+  auto checkIndex = [](FileMatchTrie const& match, llvm::StringMap<std::vector<CompileCommandRef>> const& idx, const SmallString<128>& NativeFilePath)
+  {
+    std::string Error;
+    llvm::raw_string_ostream ES(Error);
+    StringRef Match = match.findEquivalent(NativeFilePath, ES);
+    if (Match.empty())
+      return idx.end();
+    return idx.find(Match);
+  };
+
   std::vector<CompileCommand> Commands;
-  getCommands(CommandsRefI->getValue(), Commands);
+  auto tryGetCommands = [&](decltype(IndexByFile)::const_iterator it, bool withDeps)
+  {
+    bool atLeastOneExactMatch = false;
+    getCommands(it->getValue(), Commands);
+    for (CompileCommand &cc : Commands) {
+      StringRef ccfn = cc.Filename;
+      if (ccfn.endswith(FilePath)) 
+        atLeastOneExactMatch = true;
+      else if (withDeps) {
+        for (size_t i = 0; i < cc.Dependencies.size(); ++i) {
+          CompileCommand::Dependency const &d = cc.Dependencies[i];
+          StringRef fn = d.Filename;
+          if (fn.endswith(FilePath)) {
+            cc.DependencyIndex = (int)i;
+            break;
+          }
+        }
+      }
+    }
+    return atLeastOneExactMatch;
+  };
+
+  bool checkDeps = true;
+  {
+    const auto mainIdx = checkIndex(MatchTrie, IndexByFile, NativeFilePath);
+    if (mainIdx != IndexByFile.end())
+      checkDeps = !tryGetCommands(mainIdx, false);
+  }
+
+  if (!IndexByFileDep.empty() && checkDeps)
+  {
+    const auto depIdx = checkIndex(MatchTrieDep, IndexByFileDep, NativeFilePath);
+    if (depIdx != IndexByFileDep.end())
+      tryGetCommands(depIdx, true);
+
+  }
   return Commands;
 }
 
 std::vector<std::string>
 JSONCompilationDatabase::getAllFiles() const {
   std::vector<std::string> Result;
+  Result.reserve(IndexByFile.size());
+  for (const auto &CommandRef : IndexByFile)
+    Result.push_back(CommandRef.first().str());
+  return Result;
+}
+
+std::vector<std::string> JSONCompilationDatabase::getAllFilesWithDeps() const
+{
+  std::vector<std::string> Result;
+  Result.reserve(IndexByFile.size() + IndexByFileDep.size());
   for (const auto &CommandRef : IndexByFile)
     Result.push_back(CommandRef.first().str());
+  for (const auto &CommandRef : IndexByFileDep)
+    Result.push_back(CommandRef.first().str());
   return Result;
 }
 
@@ -313,6 +363,65 @@ nodeToCommandLine(JSONCommandLineSyntax Syntax,
   return Arguments;
 }
 
+static bool ParseCompileCommandDependency(llvm::yaml::MappingNode *pNode, CompileCommand::Dependency &d)
+{
+  for (auto &depKeyValue : *pNode) {
+    auto *KeyString = dyn_cast<llvm::yaml::ScalarNode>(depKeyValue.getKey());
+    if (!KeyString) {
+      return false;
+    }
+    SmallString<10> KeyStorage;
+    StringRef KeyValue = KeyString->getValue(KeyStorage);
+    llvm::yaml::Node *Value = depKeyValue.getValue();
+    if (!Value) {
+      return false;
+    }
+    auto *ValueString = dyn_cast<llvm::yaml::ScalarNode>(Value);
+    auto *SequenceString = dyn_cast<llvm::yaml::SequenceNode>(Value);
+    if (KeyValue == "file") {
+      if (!ValueString) {
+        return false;
+      }
+      SmallString<10> FileStorage;
+      StringRef FilenameValue = ValueString->getValue(FileStorage);
+      d.Filename = FilenameValue.str();
+    } else if (KeyValue == "add" || KeyValue == "remove") {
+      if (!SequenceString) {
+        return false;
+      }
+      std::vector<std::string> &v =
+          KeyValue == "add" ? d.AddArgs : d.RemoveArgs;
+      for (auto &Argument : *SequenceString) {
+        auto *Scalar = dyn_cast<llvm::yaml::ScalarNode>(&Argument);
+        if (!Scalar) {
+          return false;
+        }
+        SmallString<10> ArgStorage;
+        StringRef ArgValue = Scalar->getValue(ArgStorage);
+        v.push_back(ArgValue.str());
+      }
+    }
+  }
+  return true;
+}
+
+static bool ParseCompileCommandDependencies(llvm::yaml::SequenceNode *pDeps, std::vector<CompileCommand::Dependency> &deps)
+{
+  bool res = true;
+  for (auto &depNode : *pDeps) {
+    auto *Dep = dyn_cast<llvm::yaml::MappingNode>(&depNode);
+    if (!Dep) {
+      return false;
+    }
+    CompileCommand::Dependency d;
+    if (ParseCompileCommandDependency(Dep, d))
+      deps.push_back(std::move(d));
+    else
+      res = false;
+  }
+  return res;
+}
+
 void JSONCompilationDatabase::getCommands(
     ArrayRef<CompileCommandRef> CommandsRef,
     std::vector<CompileCommand> &Commands) const {
@@ -320,12 +429,17 @@ void JSONCompilationDatabase::getCommands(
     SmallString<8> DirectoryStorage;
     SmallString<32> FilenameStorage;
     SmallString<32> OutputStorage;
-    auto Output = std::get<3>(CommandRef);
+    auto *Output = std::get<3>(CommandRef);
+    std::vector<CompileCommand::Dependency> deps;
+    auto depsShared = std::get<4>(CommandRef);
+    if (depsShared.get()) deps = *depsShared;
+
     Commands.emplace_back(
         std::get<0>(CommandRef)->getValue(DirectoryStorage),
         std::get<1>(CommandRef)->getValue(FilenameStorage),
         nodeToCommandLine(Syntax, std::get<2>(CommandRef)),
-        Output ? Output->getValue(OutputStorage) : "");
+        Output ? Output->getValue(OutputStorage) : "",
+        std::move(deps));
   }
 }
 
@@ -355,6 +469,8 @@ bool JSONCompilationDatabase::parse(std::string &ErrorMessage) {
     llvm::Optional<std::vector<llvm::yaml::ScalarNode *>> Command;
     llvm::yaml::ScalarNode *File = nullptr;
     llvm::yaml::ScalarNode *Output = nullptr;
+    DepsShared Dependencies;
+
     for (auto& NextKeyValue : *Object) {
       auto *KeyString = dyn_cast<llvm::yaml::ScalarNode>(NextKeyValue.getKey());
       if (!KeyString) {
@@ -384,6 +500,14 @@ bool JSONCompilationDatabase::parse(std::string &ErrorMessage) {
           }
           Command->push_back(Scalar);
         }
+      } else if (KeyValue == "dependencies") {
+        if (!SequenceString) {
+          ErrorMessage = "Expected sequence as value.";
+          return false;
+        }
+        Dependencies.reset(new std::vector<CompileCommand::Dependency>());
+        if (!ParseCompileCommandDependencies(SequenceString, *Dependencies))
+          ErrorMessage = "Wrong deps";
       } else {
         if (!ValueString) {
           ErrorMessage = "Expected string as value.";
@@ -419,21 +543,40 @@ bool JSONCompilationDatabase::parse(std::string &ErrorMessage) {
     }
     SmallString<8> FileStorage;
     StringRef FileName = File->getValue(FileStorage);
-    SmallString<128> NativeFilePath;
-    if (llvm::sys::path::is_relative(FileName)) {
-      SmallString<8> DirectoryStorage;
-      SmallString<128> AbsolutePath(
-          Directory->getValue(DirectoryStorage));
-      llvm::sys::path::append(AbsolutePath, FileName);
-      llvm::sys::path::remove_dots(AbsolutePath, /*remove_dot_dot=*/ true);
-      llvm::sys::path::native(AbsolutePath, NativeFilePath);
-    } else {
-      llvm::sys::path::native(FileName, NativeFilePath);
+    auto FileNameToNative = [&Directory](StringRef FileName)->SmallString<128>
+    {
+      SmallString<128> NativeFilePath;
+      if (llvm::sys::path::is_relative(FileName)) {
+        SmallString<8> DirectoryStorage;
+        SmallString<128> AbsolutePath(
+            Directory->getValue(DirectoryStorage));
+        llvm::sys::path::append(AbsolutePath, FileName);
+        llvm::sys::path::remove_dots(AbsolutePath, /*remove_dot_dot=*/ true);
+        llvm::sys::path::native(AbsolutePath, NativeFilePath);
+      } else {
+        llvm::sys::path::native(FileName, NativeFilePath);
+      }
+      return NativeFilePath;
+    };
+    SmallString<128> NativeFilePath = FileNameToNative(FileName);
+
+    if (!ErrorMessage.empty())
+    {
+      llvm::errs() << "Error with deps for file " << NativeFilePath << "\n";
     }
-    auto Cmd = CompileCommandRef(Directory, File, *Command, Output);
+
+    auto Cmd = CompileCommandRef(Directory, File, *Command, Output, Dependencies);
     IndexByFile[NativeFilePath].push_back(Cmd);
-    AllCommands.push_back(Cmd);
     MatchTrie.insert(NativeFilePath);
+    if (Dependencies.get())
+    {
+      for (CompileCommand::Dependency const &d : *Dependencies) {
+        SmallString<128> NativeFilePathDep = FileNameToNative(d.Filename);
+        IndexByFileDep[NativeFilePathDep].push_back(Cmd);
+        MatchTrieDep.insert(NativeFilePathDep);
+      }
+    }
+    AllCommands.push_back(Cmd);
   }
   return true;
 }
